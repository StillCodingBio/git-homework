---
title: "Final_BIO658_Stillman"
author: "Anthony Stillman"
date: "2025-11-10"
output: html_document
bibliography: final_ref.bib 
---

# TITLE:
**RNA-seq Data Analysis of Frontal Cortex Samples from Individuals that have had COVID-19.**

# INTRODUCTION:

Severe acute respiratory syndrome coronavirus 2 (SARS-CoV-2), better know as COVID-19, has left a significant mark on the world (@3). The World Health Organization (WHO) reports that there have been ~779 million reported cases of COVID-19 as of toward the end of 2025 (@2). The initial infection and symptoms of COVID-19 have been a significant health burden by itself, but now there is a lingering affect know as Long COVID. Long COVID is various chronic conditions that affect individuals after they have had COVID-19 (@4). Long COVID is difficult to define due to it not seemingly affecting the same biological systems from person to person (@4). There have been various studies across different biological systems of former COVID-19 patients to better understand Long COVID. A biological system that can be affected by Long COVID is the brain (@5). COVID-19 appears to speed up aging in the brain through various mechanisms (@6). This report is interested on taking the RNA-Seq data derived brain tissue samples of people who have had COVID-19 and determining if COVID-19 creates chronic conditions that affect the brain. This report will use data from "Severe COVID-19 is associated with molecular signatures of aging in the human brain" by Maria Mavrikaki, Jonathan D. Lee, Isaac H. Solomon, and Frank J. Slack; the data is composed of individuals that have and have not had COVID-19 across genders and ages (@1).  

# METHODS:

## Processing and Analysis Platform.

All the data processing, analysis, and figure creation was done with R and RStudio. Please see the Computational Component section for the library of packages used and how they were used.

## Preprocessing:

**Data:** The data is composed of RNA-sequencing data from frontal cortex samples. The samples were taken from 22 individuals that have had COVID-19 and 23 individuals that have not had COVID-19 (@1). The samples were from individuals of various ages and genders.  

**Data retrieval:** The data of interest is cataloged in the GEO database as GSE188847 (https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE188847&format=file). This package of files were download and untarred with R.

**Data unpacking:** The function "GEOquery::getGEO" was used to retrieve experimental details for GSE188847 and structure it; the phenotype data was then extracted from the getGEO object with "Biobase::pData". The read counts and abundances were extracted and structured from the GSE188847 file via "tximport" using the salmon format. The phenotype, counts, and abundance data was formatted together into a summarize experiment data format using "SummarizedExperiment".  

**Connect to Ensembl:** useMart was used to link each mRNA transcription ID with their associated ensemble gene ID, gene symbol, biotype, and description. 

**Sample Isolation:** The GSE188847 had other experimental groups that were outside our interest. These were removed from the data set. In addition a variable of unaffected (Never had COVID-19) and affected (Has had COVID-19) was added to the data per sample for later use. 

**Low gene expression filtering and normalization:** The experimental summary data set was turned into an DGEList object with "edgeR::SE2DGEList". Duplicated data was removed from the DGEList object via R functions. Genes with low expression were removed from the DGEList object with "edgeR::filterByExpr". The data was normalized based on library size via "edgeR::normLibSizes", which uses the TMM normalization method.

## Batch Effect Correction.

The batches of sample processing and reading could not be determined. To remove the batch effect "sva" methods in combination with "limma::removeBatchEffect" were used to remove the batch affect from the data. Past COVID-19 infection, age, and sex were used for the "sva" biological components. The affect of the batch effect correction was visualized by sum of counts per sample, hierarchical clustering on the top 10% most variable genes, PCA plots, and boxplot of log2(expression) between samples; these visualizations were done before and after the batch effect correction. 

After the batch effect correction the a multidimensional scaling plot was done to further visualize the relationship between samples and row standard deviations versus row means plot to illustrate the distribution of the data. 

## Differential Expression Analysis.

**Design:** The variants for the expression analysis were gender as an factor, age as an continuous factor, and previous COVID-19 infection as a factor. 

**Estimated dispersion:** "edgeR::estimateDisp" was used to calculate the dispersion of the data. This was further illustrated via BCV plot ("edgeR::plotBCV").

**Modeling:** A general linear model was fitted onto the data with "edgeR::glmFit" based on the design. A likelihood-ratio test was run on the fitted model with "edgeR::glmLRT" with previous COVID-19 exposure as the coefficient, revealing up and down regulated genes between the COVID-19 and control groups. The differential expression was visualized with a Mean-Difference Plot ("limma::plotMD").

**Multiple testing correction methods:** False Discovery Rate (FDR) correction method were used on the data. This method is very effective at adjusting p-values of large number of tests. 

## Functional Enrichment Analysis.

Functional enrichment analysis was done with code created by Dr. Mikhail Dozmorov (https://github.com/mdozmorov). The analysis was done on GSEA and over representation analysis using the three gene ontology domains (Biological Process, Molecular Function, Cellular Component (@7)) and KEGG pathways (@8).



```{r Library, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
#Load libraries.
library(tximport)
library(Biobase)
library(SummarizedExperiment)
library(org.Hs.eg.db)
library(GEOquery)
library(stringr)
library(tidyr)
library(limma)
library("DESeq2")
library(ggVennDiagram)
library(biomaRt)
library(vsn)
library(tibble)
library(circlize)
library(knitr)
library(pander)
library(openxlsx)
library(writexl)
library(DT)
library(edgeR)
library(sva)
library(ggrepel)
library(reshape2)
library(plotly)
library(dplyr)
library(readr)
# library(MDmisc)
library(heatmaply)
# library(shiny)
library(ggplot2)
library(pheatmap)
# source("https://raw.githubusercontent.com/mdozmorov/enrichR/master/R/api_wrapper.R")
library(enrichR) # install.packages("enrichR")
# source("/Users/mdozmorov/Documents/Work/GitHub/RNA-seq/utils_NF.R")   # Helper functions
library(annotables) # devtools::install_github("stephenturner/annotables") Annotations of Ensembl IDs
library("ggsci")
library(scales)
library(metap)
library(ggVolcano)
 library(readxl)
library(gridExtra)
library(grid)
library(kableExtra)
library(stringr)
```


```{r Download data, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Retrieve experimantal data.
# Set directory.
dir <- "Final_BIOS658_Stillman"
setwd(dir)
# GSE ID.
GSE <- "GSE188847"
# URL of the GEO SOFT file
url <- "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE188847&format=file"
# Destination file name
destfile <- "GSE188847_RAW.tar"
# Download the file
download.file(url, destfile, mode = "wb")
# Check if the file exists
if (file.exists(destfile)) {
  message("Download complete: ", destfile)
} else {
  warning("Download failed!")
}
# Uncompress GSE188847_RAW.tar data.
untar(destfile, exdir = "GSE188847_RAW")
```

```{r Get GEO, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Download GEO GSE188847 series matrix.
gse <- getGEO("GSE188847", GSEMatrix = TRUE, destdir = dir)
```

```{r Unpack data, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# List all .sf.txt folders in GSE188847_RAW. .sf.txt folders contain the .sf files.
files <- list.files("GSE188847_RAW",
                    pattern = ".gz$", full.names = TRUE)
# Optional: named vector with sample names. Strip files names down to sample name with gsub.This will transfer over to tximport.
# gsub perform replacement of the first and all matches respectively within each element of a character vector.
names(files) <- gsub("_.*", "", basename(files))
# Read Salmon files. Takes the .sf files in the file list and compiles them into a lists.
txi <- tximport(files, type = "salmon", txOut = TRUE)  # txOut=TRUE keeps transcript level
```

```{r geo vs txi check, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Extract GEO sample names.
geo_samples <- sampleNames(gse[[1]])
# Extract txi sample names.
txi_samples <- colnames(txi$counts)
# Check if they match
all(geo_samples %in% txi_samples)   # Should be TRUE
```

```{r Assign pheno. data, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Create colData from GEO phenoData. pData access phenotypic data from the GEO object.  
colData <- as.data.frame(pData(gse[[1]]))  # convert to data.frame
# Check if they match
all(geo_samples %in% rownames(colData))   # Should be TRUE
# Assign geo_sample (sample names) to the row names of colData.
rownames(colData) <- geo_samples          # ensure rownames match columns
```

```{r Get Counts from txi, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Extract gene counts from txi object. Counts is raw counts. 
txi_counts <- txi$counts[, geo_samples]
# Extract TPM from txi object. Abundance is the quantification of expression levels.
txi_tpm <- txi$abundance[, geo_samples]
```

```{r Create SummarizedExperiment, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Create the SummarizedExperiment. Combine counts, TPM, and ColData. Now the phenotype and gene expression can be compared.
se <- SummarizedExperiment(
  assays = list(
    counts = txi_counts,
    TPM    = txi_tpm
  ),
  colData = colData
)
# Look at summarized Experiment.
se
```

```{r Remove ID versions, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Remove ID versions from the gene IDs with gsub.
# https://stackoverflow.com/questions/23413331/how-to-remove-last-n-characters-from-every-element-in-the-r-vector
se@NAMES <- gsub("\\..*", '', se@NAMES)
```

```{r Retrieve ensembl, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Connect to Ensembl
ensembl <- useMart("ensembl")
# Human pattern
human_datasets <- listDatasets(ensembl)
# Assign human pattern.
human_dataset <- human_datasets[human_datasets$dataset == "hsapiens_gene_ensembl",]
# Connect to the chosen human dataset
ensembl_h <- useMart("ensembl", dataset = human_dataset$dataset)

# Create data template with orders
extra_data <- as.data.frame(se@NAMES) # Assign nsembl_transcript_id
colnames(extra_data) <- "ensembl_transcript_id" # Give column name
c_order <- as.data.frame(1:nrow(extra_data)) # Assign order
colnames(c_order) <- "order" # Get column name
extra_data <- cbind(extra_data, c_order) # bind together.

# Use getBM to get human "ensembl_transcript_id", "external_gene_name", "ensembl_gene_id", and "description"
h <- # Assign
  getBM( # Start getBM
  attributes = c("ensembl_transcript_id", "external_gene_name", "ensembl_gene_id", "description", "gene_biotype"), # Information to get
  filters = "ensembl_transcript_id", # filter by "ensembl_transcript_id"
  values = se@NAMES, # Use names
  mart = ensembl_h # What ensembl to use
)  
 
# Merge the getBM data to the extra data template fill in blanks of getBM data
extra_data <- merge(x = extra_data, y = h, by = "ensembl_transcript_id", all.x =TRUE)
# Order the data
extra_data_order <- extra_data[order(extra_data$order),]
# Remove order.
extra_data <-
  extra_data %>%
  dplyr::select(., -order)

# Google
# https://www.biostars.org/p/66529/
# https://stackoverflow.com/questions/17878048/merge-two-data-frames-while-keeping-the-original-row-order
```

```{r Isolate covid and control samples, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Create new dataframe that contains samples that have had covid.
COVID_cells <- se@colData@listData$title[grepl("COVID",se@colData@listData$title)]
# Create new dataframe that contains samples that have not had covid.
Control_cells <- se@colData@listData$title[grepl("CONTROL",se@colData@listData$title)]
# Create se of covid and control samples
COVID_Control_cells <- c(COVID_cells, Control_cells) # Create list of control and covid samples
T_cells <- se@colData@listData$title %in% COVID_Control_cells # Boolean of samples in se
se_COVID_Control_cells <- se[,T_cells] # Isolate control and covid samples in se
```

```{r Create affected variable, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Assign affected and unaffected groups 
COVID_EXP <- ifelse(grepl("COVID", se_COVID_Control_cells@colData@listData$title), "Affected", "Unaffected")
se_COVID_Control_cells@colData@listData$COVID_EXP <- COVID_EXP
# Assign affected and unaffected groups factor
COVID_EXP_F <- ifelse(grepl("COVID", se_COVID_Control_cells@colData@listData$title), 1, 0)
se_COVID_Control_cells@colData@listData$COVID_EXP_F <- factor(COVID_EXP_F)
```

# RESULTS

## Quality Assessment Before SVA.

```{r edgeR normalization, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Adjusut data
# Turn se_COVID_Control_cells into a DGEList.
y <- SE2DGEList(se_COVID_Control_cells )
# Order samples.
o <- order(rowSums(y$counts), decreasing = TRUE)
# Order samples by counts
y <- y[o,]
# Identify duplicates.
d <- duplicated(rownames(y$counts))
# Remove duplicates from DGEList
y <- y[!d,]
# Number of rows after processing
nrow(y)
# Filter out low expressions
keep <- filterByExpr(y)
y <- y[keep, keep.lib.sizes = FALSE]
# Recompute the library sizes.
y$samples$lib.size <- colSums(y$counts)
# TMM normalization is applied to this dataset to account for compositional difference between the libraries.
y <- normLibSizes(y)
# Look at normal factor.
y$samples$norm.factors
```

Before conduction SVA correction, the data was visualized. The gene expression between samples are uneven; even with logitherically adjusting them (Figure 1). This can be partially explained by the samples having a variability of expression counts in the first place (Figure 2). To determine the correlation of the samples by calculating the interaction analysis by chi-square (IAC) for the 10% highest variable genes; there appears to be high between all the samples (Figure 3). The hierarchical clustering of the samples do not a line with groups (Figure 3). To further show the relationship between the samples, a principal component analysis (PCA) was done on the counts; the the statistical summary of the PCA results (Table 1) and the visualization (Figure 4) suggests that the relationship between the samples is not based on group. These findings overall suggest that the data is suffering from batch effect.      
```{r Visualize Correlation before SVA, echo=FALSE, message=FALSE, warning=FALSE}
# Create link between sample name and affect
ref_title_exp <- data.frame(Sample = y$samples$title,
                          group = y$samples$COVID_EXP)
# Log of counts before SVA
log2_mat <- log2(y$counts + 1)
# Replace Colnames with Sample names
colnames(log2_mat) <- y$samples$title
# Adjust data to be used in box plot
df_sva_b <- # Assign
  log2_mat %>% # Get log2_mat
  as.data.frame() %>% # Turn to data.frame
  tibble::rownames_to_column("ENST") %>% # Turn ENST column into rownames.
  pivot_longer( # Pivot data by sample names
    cols = -ENST,
    names_to = "Sample",
    values_to = "log2expr"
  ) %>%
  left_join(., ref_title_exp, by = "Sample") # Joint samples to group
# Visualize boxplots after no SVA correction
ggplot(df_sva_b, aes(x = Sample, y = log2expr, fill = group)) + # start ggplot
  geom_boxplot(outlier.size = 0.3) + # Start boxplot
  scale_fill_brewer(palette = "Set2") + # Set palette for scale
  theme_bw() + # black and white theme
  theme(
    axis.text.x = element_blank(),   # remove sample labels
    axis.ticks.x = element_blank(),   # remove ticks if you also want them gone
    plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0         
    )) +
  labs(title = sprintf("Figure 1: Log2(expr + 1) — Before SVA correction"), # Title
       x = "Sample", y = "log2(expr + 1)",
       caption = str_wrap("The log2 of each expression grouped together by groups in boxplot. 1 was added to each expression value to avoid error."))
```
\
\
```{r Sample annotation1, , echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Create sample annotation
sample_annotation <- data.frame(
  Sample = y$samples$title,
  Group = y$samples$COVID_EXP,
  Geo = y$samples$geo_accession
)
```
\
\
```{r Sum of Counts, echo=FALSE, message=FALSE, warning=FALSE}
# Get count data
counts <- y$counts
# Rename columns with sample names
colnames(counts) <- y$samples$title
# Check to see if share sample names
#all.equal(sample_annotation$Sample, colnames(counts))
# Turn counts into datafame
counts <- data.frame(counts)
# Create gene columns
counts <- # Assign to self
  counts %>% # Call data
  tibble::rownames_to_column(., "enstgene") # Make ENST rownames into column
# Calculate column-wise sums for samples (excluding Geneid)
sample_sums <- colSums(counts[, -1])  
# Create a data frame with sums and merge with the sample annotation
sample_sums_df <- data.frame(Sample = names(sample_sums), Sum = sample_sums)
# Combine Sample, sum, and group into one dataframe
sample_sums_annotated <- merge(sample_sums_df, sample_annotation, by = "Sample")  
# Order by the sum of counts
sample_sums_annotated <- sample_sums_annotated[order(sample_sums_annotated$Sum), ]
# Create a bar plot of treatment and sum counts
ggplot(sample_sums_annotated, aes(x = reorder(Sample, Sum), y = Sum, fill = Group)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  coord_flip() +
  labs(x = "Sample", y = "Sum of Counts", title = "Figure 2: Sum of Counts by Sample before SVA Correction",
       caption = str_wrap("The sum of expression counts was calculated for each samples and displayed.")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.caption = element_text(
          size = 10,       
          color = "black", 
          face = "italic",  
          hjust = 0))

```
\
\
```{r Sample annotation2, echo=FALSE, results='hide', message=FALSE, warning=FALSE, fig.keep = "none"}
my_caption <- textGrob(str_wrap("The  Interaction Analysis by Chi-Square (IAC) was calculated bewteen each sample before SVA correction for the top 10% of\n variable genes. This is map on the above heatmap with cluster designation"),
                       gp = gpar(fontsize = 8, fontface = "italic"),
                       just = "left", x = 0.05)
# Create matrix of couunts
mtx <- cpm(y$counts, normalized.lib.sizes = TRUE)
# set column names to sample names
colnames(mtx) <- y$samples$title
# The function varFilter removes features exhibiting little variation across samples. Such non-specific filtering can be advantageous for downstream data analysis.
# https://www.rdocumentation.org/packages/methylumi/versions/2.18.2/topics/varFilter
mtx_to_plot <- varFilter(mtx, var.cutoff = 0.9)
# IAC sample association.
IAC <- mtx_to_plot %>% cor(. , use = "pairwise.complete.obs",  method = "pearson") 
# Create dataframe of groups.
plot_annotations <- data.frame(Group = y$samples$COVID_EXP)
# Combine groups and treatments
rownames(plot_annotations) <- y$samples$title
# Create heat and cluster map of association.
one <- pheatmap(IAC, annotation_col = plot_annotations, clustering_method = "ward.D", main = "Figure 3: IAC Heat Map before SVA Correction", fontsize_row = 5, fontsize_col = 5)
```

```{r heat grid, echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(
    grobs = list(one[[4]], my_caption), # one[[4]] is the main heatmap grob
    heights = c(1, 0.1), # Adjust as needed (e.g., 1 for plot, 0.1 for caption)
    ncol = 1
)
# google(pheatmap r caption)
```
\
\
```{r PCA plot1, echo=FALSE, message=FALSE, warning=FALSE}
# PCA: Check for batch effects. Select one batch, to color points by its assignment
pca <-  mtx_to_plot %>% t  %>% scale %>% prcomp
# Look at the statistic of PC
pca_df <- data.frame(summary(pca)$importance)[, 1:min(5, ncol(summary(pca)$importance))] # Percent of variance explained
knitr::kable(round(pca_df, 3), caption = "Table 1: Summary of PCA results before SVA correction") %>% add_footnote( label = "*The expression counts were put through Principal Component Analysis. The results are summarized above.*")
colorby <- "Group" # covariates[2]
# Create cluster group graph
pt <- ggplot(data = data.frame(pca$x, sample_annotation, samples = sample_annotation$Sample, stringsAsFactors = F), # Use data set projected on the PC as the data.
             aes(x = as.numeric(PC1), y = as.numeric(PC2), label = samples)) + # Set x as PC1 and y as PC2.
  theme(plot.title = element_text(lineheight = 0.8, face="bold"),  plot.caption = element_text(
          size = 10,       
          color = "black", 
          face = "italic",  
          hjust = 0)) + # Select theme.
  ggtitle("Figure 4: PCA of Samples Before SVA Correction") + # Put in title
  geom_point(aes(color = eval(parse(text = colorby))), size = 3) + # Create point graph
  geom_text_repel(colour = "black", size = 3) + # Give each point a color
  geom_hline(yintercept = 0, colour = "gray65") + # Set hor. line color
  geom_vline(xintercept = 0, colour = "gray65") + # Set ver. line color
  labs(color = colorby, caption = str_wrap("The expression counts were put through Principal Component Analysis. The two most prominent PC are set as axises and the samples are plotted on them to illustrate relationship.")) + # Set labels by groups
  scale_x_continuous(name = paste0("PC1, ", round(summary(pca)$importance[2,1] * 100, digits = 2), "% variability" )) + # Set scale for x
  scale_y_continuous(name = paste0("PC2, ", round(summary(pca)$importance[2,2] * 100, digits = 2), "% variability" )) # Set scale for y
plot(pt) # Plot
# https://stackoverflow.com/questions/33710240/how-to-attach-a-title-to-a-data-frame-in-rr
```

```{r SVA, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# SVA: estimate surrogate variables and remove their effects
# Prepare data and design matrices for svaseq
dat_for_sva <- as.matrix(y$counts)  
# Assign affected variable.
EXP_F <- y$samples$COVID_EXP_F
# Assign ages
age_v <- as.integer(y$samples$age.ch1)
# Assign sex.
sex_v <- y$samples$Sex.ch1
sex_f <- ifelse(sex_v == "M", 0, 1)
sex_f <- factor(sex_f)
# Create models for SVA
mod = model.matrix(~EXP_F + age_v + sex_f) # Model with biological charactristics of interest
mod0 <- cbind(mod[,1])  # null model (intercept-only)
# Estimate number of surrogate variables automatically (Leek method)
n.sv <- num.sv(dat_for_sva, mod, method = "leek")
cat("Estimated number of surrogate variables:", n.sv, "\n")
# Run svaseq to estimate surrogate variables
svseq <- svaseq(dat = dat_for_sva, mod = mod, mod0 = mod0, n.sv = n.sv-1)
# Remove surrogate variable effects using limma::removeBatchEffect (treat sv's as covariates)
sv_mat <- svseq$sv
sva_corrected <- limma::removeBatchEffect(dat_for_sva, covariates = sv_mat)
# Create link between sample name and affect
ref_geo_exp <- data.frame(Sample = y$samples$geo_accession,
                          group = y$samples$COVID_EXP)
# Create link between sample name and affect
ref_title_exp <- data.frame(Sample = y$samples$title,
                          group = y$samples$COVID_EXP)
```


```{r SVA12, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Replace negative values with 0
sva_corrected[sva_corrected <= 0] = 0
# Visualize boxplots after SVA correction
sva_corrected_log2 <- log2(sva_corrected + 1)
# Change columns to sample names
colnames(sva_corrected_log2) <- y$samples$title
# Remove all negatice numbers
sva_corrected_log2[is.na(sva_corrected_log2)] = 0
# Adjust data to be used in box plot
df_sva <- # Assign
  sva_corrected_log2 %>% # Get log2 data
  as.data.frame() %>% # Turn into data frame
  tibble::rownames_to_column("ENST") %>% # Turn ENST column into rownames
  pivot_longer( # Pivot data on samples
    cols = -ENST,
    names_to = "Sample",
    values_to = "log2expr"
  ) %>%
  left_join(., ref_title_exp, by = "Sample") # Join group to data
```

```{r Library Size, echo=FALSE, message=FALSE, warning=FALSE}
cat("Library size was", sum(y$samples$lib.size), "before SVA correction and is now", sum(sva_corrected), "after SVA correction." )
```

```{r Assign SVA counts to main data, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
dim(y$counts)
dim(sva_corrected)
y$counts[1]
sva_corrected[1]
# Assign SVA corrected counts to y
y$counts <- sva_corrected
```

```{r Sample Annotation3, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Create sample annotation
sample_annotation <- data.frame(
  Sample = y$samples$title,
  Group = y$samples$COVID_EXP,
  Geo = y$samples$geo_accession
)
```

After conduction SVA correction, the data was visualized. The gene expression between samples are even (Figure 5). This can be partially explained by the samples' expression counts normalization (Figure 6). To determine the correlation of the samples by calculating the interaction analysis by chi-square (IAC) for the 10% highest variable genes; there appears to be high correlation between all the samples within a group (previous COVID-19 infection or not) and lower correlation between groups (Figure 7). The hierarchical clustering of the samples do a line with groups (Figure 7). To further show the relationship between the samples, a principal component analysis (PCA) was done on the counts; the the statistical summary of the PCA results (Table 2) and the visualization (Figure 8) suggests that the relationship between the samples is based on group. These finding overall suggests that the batch effect has been removed from the samples.


```{r Visualize Correlation after SVA, echo=FALSE, message=FALSE, warning=FALSE}
# Create link between sample name and affect
ref_title_exp <- data.frame(Sample = y$samples$title,
                          group = y$samples$COVID_EXP)
# Log of counts before SVA
log2_mat <- log2(y$counts + 1)
# Replace Colnames with Sample names
colnames(log2_mat) <- y$samples$title
# Adjust data to be used in box plot
df_sva_b <- # Assign
  log2_mat %>% # Get log2_mat
  as.data.frame() %>% # Turn to data.frame
  tibble::rownames_to_column("ENST") %>% # Turn ENST column into rownames.
  pivot_longer( # Pivot data by sample names
    cols = -ENST,
    names_to = "Sample",
    values_to = "log2expr"
  ) %>%
  left_join(., ref_title_exp, by = "Sample") # Joint samples to group
# Visualize boxplots after no SVA correction
ggplot(df_sva_b, aes(x = Sample, y = log2expr, fill = group)) + # start ggplot
  geom_boxplot(outlier.size = 0.3) + # Start boxplot
  scale_fill_brewer(palette = "Set2") + # Set palette for scale
  theme_bw() + # black and white theme
  theme(
    axis.text.x = element_blank(),   # remove sample labels
    axis.ticks.x = element_blank(),   # remove ticks if you also want them gone
    plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0         
    )) +
  labs(title = sprintf("Figure 5: Log2(expr + 1) — After SVA correction"), # Title
       x = "Sample", y = "log2(expr + 1)",
       caption = str_wrap("The log2 of each expression grouped together by groups in boxplot. 1 was added to each expression value to avoid error."))
```

```{r Sum of Counts2, echo=FALSE, message=FALSE, warning=FALSE}
# Get count data
counts <- y$counts
# Rename columns with sample names
colnames(counts) <- y$samples$title
# Check to see if share sample names
# all.equal(sample_annotation$Sample, colnames(counts))
# Turn counts into datafame
counts <- data.frame(counts)
# Create gene columns
counts <- # Assign to self
  counts %>% # Call data
  tibble::rownames_to_column(., "enstgene") # Make ENST rownames into column
# Calculate column-wise sums for samples (excluding Geneid)
sample_sums <- colSums(counts[, -1])  
# Create a data frame with sums and merge with the sample annotation
sample_sums_df <- data.frame(Sample = names(sample_sums), Sum = sample_sums)
# Combine Sample, sum, and group into one dataframe
sample_sums_annotated <- merge(sample_sums_df, sample_annotation, by = "Sample")  
# Order by the sum of counts
sample_sums_annotated <- sample_sums_annotated[order(sample_sums_annotated$Sum), ]
# Create a bar plot of treatment and sum counts
ggplot(sample_sums_annotated, aes(x = reorder(Sample, Sum), y = Sum, fill = Group)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  coord_flip() +
  labs(x = "Sample", y = "Sum of Counts", title = "Figure 6: Sum of Counts by Sample After SVA Correction",
       caption = str_wrap("The sum of expression counts was calculated for each samples and displayed.")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        plot.caption = element_text(
          size = 10,       
          color = "black", 
          face = "italic",  
          hjust = 0))

```

```{r Sample annotation4, echo=FALSE, results='hide', message=FALSE, warning=FALSE, fig.keep = "none"}
my_caption <- textGrob(str_wrap("The  Interaction Analysis by Chi-Square (IAC) was calculated bewteen each sample after SVA correction for the top 10% of\n variable genes. This is map on the above heatmap with cluster designation"),
                       gp = gpar(fontsize = 8, fontface = "italic"),
                       just = "left", x = 0.05)
# Create matrix of couunts
mtx <- cpm(y$counts, normalized.lib.sizes = TRUE)
# set column names to sample names
colnames(mtx) <- y$samples$title
# The function varFilter removes features exhibiting little variation across samples. Such non-specific filtering can be advantageous for downstream data analysis.
# https://www.rdocumentation.org/packages/methylumi/versions/2.18.2/topics/varFilter
mtx_to_plot <- varFilter(mtx, var.cutoff = 0.9)
# IAC sample association.
IAC <- mtx_to_plot %>% cor(. , use = "pairwise.complete.obs",  method = "pearson") 
# Create dataframe of groups.
plot_annotations <- data.frame(Group = y$samples$COVID_EXP)
# Combine groups and treatments
rownames(plot_annotations) <- y$samples$title
# Create heat and cluster map of association.
one <- pheatmap(IAC, annotation_col = plot_annotations, clustering_method = "ward.D", main = "Figure 7: IAC Heat Map After SVA Correction", fontsize_row = 5, fontsize_col = 5)
```

```{r heat map2, echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(
    grobs = list(one[[4]], my_caption), # one[[4]] is the main heatmap grob
    heights = c(1, 0.1), # Adjust as needed (e.g., 1 for plot, 0.1 for caption)
    ncol = 1
)
# google(pheatmap r caption)
```
\
\
```{r PCA plot2, echo=FALSE, message=FALSE, warning=FALSE}
# PCA: Check for batch effects. Select one batch, to color points by its assignment
pca <-  mtx_to_plot %>% t  %>% scale %>% prcomp
# Look at the statistic of PC
pca_df <- data.frame(summary(pca)$importance)[, 1:min(5, ncol(summary(pca)$importance))] # Percent of variance explained
knitr::kable(round(pca_df, 3), caption = "Table 2: Summary of PCA results After SVA correction") %>% add_footnote( label = "*The expression counts were put through Principal Component Analysis. The results are summarized above.*")
colorby <- "Group" # covariates[2]
# Create cluster group graph
pt <- ggplot(data = data.frame(pca$x, sample_annotation, samples = sample_annotation$Sample, stringsAsFactors = F), # Use data set projected on the PC as the data.
             aes(x = as.numeric(PC1), y = as.numeric(PC2), label = samples)) + # Set x as PC1 and y as PC2.
  theme(plot.title = element_text(lineheight = 0.8, face="bold"),  plot.caption = element_text(
          size = 10,       
          color = "black", 
          face = "italic",  
          hjust = 0)) + # Select theme.
  ggtitle("Figure 8: PCA of Samples After SVA Correction") + # Put in title
  geom_point(aes(color = eval(parse(text = colorby))), size = 3) + # Create point graph
  geom_text_repel(colour = "black", size = 3) + # Give each point a color
  geom_hline(yintercept = 0, colour = "gray65") + # Set hor. line color
  geom_vline(xintercept = 0, colour = "gray65") + # Set ver. line color
  labs(color = colorby, caption = str_wrap("The expression counts were put through Principal Component Analysis. The two most prominent PC are set as axises and the samples are plotted on them to illustrate relationship.")) + # Set labels by groups
  scale_x_continuous(name = paste0("PC1, ", round(summary(pca)$importance[2,1] * 100, digits = 2), "% variability" )) + # Set scale for x
  scale_y_continuous(name = paste0("PC2, ", round(summary(pca)$importance[2,2] * 100, digits = 2), "% variability" )) # Set scale for y
plot(pt) # Plot
# https://stackoverflow.com/questions/33710240/how-to-attach-a-title-to-a-data-frame-in-rr
```

## Differential expression

After the expression counts have been normalized and the batch effect addressed, differential expression analysis commenced. The tags seem to follow the a common trend (Figure 9). Table 3 has an example of the count data being analyzed. A model was created that incorporated the age, sex, and if the patient had previously had COVID-19 then the data was fitted to a general linear model with this model. This model was analyzed with a likelihood-ratio test with previous COVID-19 infection being the coefficient. This was used to determine the tags of the data, the top 10 tags are displayed in table 4. The total tags and their directions are shown in table 5 and illustrated in figure 10. The most differential expressed genes are visually different between the people who have been affected with COVID-19 and not affected (Figure 11).      

```{r Creating design, echo=FALSE, results='hide', message=FALSE, warning=FALSE, include = FALSE}
# Assign affected variable.
EXP_F <- y$samples$COVID_EXP_F
# Assign ages
age_v <- as.integer(y$samples$age.ch1)
# Assign sex.
sex_v <- y$samples$Sex.ch1
sex_f <- ifelse(sex_v == "M", 0, 1)
sex_f <- factor(sex_f)
# Create design that compares unaffected and affected.
design <- model.matrix(~EXP_F + age_v + sex_f)
# Assign row names to design based on variable y.
rownames(design) <- colnames(y)
# Inspect design.
head(design)
# Estimate dispersion of y data based on deign.
y <- estimateDisp(y, design, robust=TRUE)
# Extract common dispersion.
y$common.dispersion
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
cat("Common dispersion is", y$common.dispersion, "for this data set." )
# Plot the BCV.
plotBCV(y) +
  title("Figure 9: BCV Plot of Expression")  +
  title(sub = "The x-axis is the average log2 of CPM and the y-axis is the genewise biological coefficient of variation (BCV)", adj = 0.5, line = 4, font.sub = 3, cex.sub = 1) 
# google("r caption below plotBCV plot")
# https://www.rdocumentation.org/packages/edgeR/versions/3.14.0/topics/plotBCV
# https://www.researchgate.net/figure/Scatterplot-of-the-biological-coefficient-of-variation-BCV-against-the-average_fig3_304186082 
```


```{r Create linear model, echo=FALSE, message=FALSE, warning=FALSE}
# Fit general linear model to y based on design.
fit <- glmFit(y, design)
# Get likelihood-ratio test.
lrt <- glmLRT(fit, coef = "EXP_F1")
# Extracts the top DE tags in a data frame for a given pair of groups, ranked by p-value or absolute log-fold change.
# https://www.rdocumentation.org/packages/edgeR/versions/3.14.0/topics/topTags
# Formating toptag data to fit into table.
df1 <- data.frame(topTags(lrt))
df1$logFC <- round(df1$logFC, 3)
df1$logCPM <- round(df1$logCPM, 3)
df1$LR <- round(df1$LR, 3)
df1$PValue <- formatC(df1$PValue , format = "e", digits = 3)
df1$FDR <- formatC(df1$FDR , format = "e", digits = 3)
```


```{r Determine significant DEGs, echo=FALSE, message=FALSE, warning=FALSE}
# Order lrt based on p-values.
o <- order(lrt$table$PValue)
# Computes counts per million (CPM) or reads per kilobase per million (RPKM) values.
# https://www.rdocumentation.org/packages/edgeR/versions/3.14.0/topics/cpm
# Top 10.

knitr::kable(head(round(cpm(y)[o[1:10], 1:10], 3)), caption = "Table 3: Example of Count per Million Data") %>% add_footnote( label = "*The top 10 expression levels counts per million example.*")
# Classify a series of related t-statistics as up, down or not significant. A number of different multiple testing schemes are offered which adjust
# for multiple testing down the genes as well as across contrasts for each gene. 
# https://www.rdocumentation.org/packages/limma/versions/3.28.14/topics/decideTests

knitr::kable(df1, caption = "Table 4: Statitical Summary of the top 10 tags", digits = 5) %>% add_footnote( label = "*Statitical summary of top ten tags. logFC = logarithmic Fold Change, logCPM = log2 of copies per million, LR = likelihood ratio, and PValue = p-value, FDR = adjusted p-value.*")

# Summarize results
df1 <- summary(decideTests(lrt, adjust.method = "fdr", p.value = 0.05))
df1 <- as.data.frame(df1)
colnames(df1) <- c("Tags", "N", "Count")
df1 <-
  df1 %>%
  dplyr::select(., -N)

knitr::kable(df1, caption = "Table 5: Tags Counts")%>% kable_styling(full_width = FALSE) %>% add_footnote( label = "*A count of expression levels for tags relative to the no previous COVID-19 infection group to the previous COVID-19 group. The counts are of the expression that have relatively increase (Up), expression levels that have relatively decrease (Down), and have not changed (NotSig). The test for significants was done on the FDR values with a alpha value of 0.05*")
```

```{r plotMD, echo=FALSE, message=FALSE, warning=FALSE}
# Make MD plot of ltr.
plotMD(lrt, main = "Figure 10: Mean Difference Plot of Expression Data") +
  title(sub = str_wrap("The x-axis is the log fold change and the y-axis is the average log CPM."), adj = 0.5, line = 4, font.sub = 3, cex.sub = 1) 
# Add lines.
abline(h=c(-1, 1), col="blue")
```

```{r Top 10 Degs compare, echo=FALSE, message=FALSE, warning=FALSE}
# Create reference between ENST and Genes
ref_geo_genes <- extra_data[,1:2]
colnames(ref_geo_genes) <- c("ENST", "Genes")
# Create a reference of geo accession to COVID_EXP
ref_geo_exp <- data.frame(GSM = y$samples$geo_accession,
                          CE = y$samples$COVID_EXP)
# Get top 10 DEGs names
DEGs_10 <- rownames(topTags(lrt, n = 10))
# Get CPM for top 10 DEGs as data.frame
y_10_cpm <- as.data.frame(cpm(y$counts)[DEGs_10,])
# Turn gene ideas into own column 
y_10_cpm <- tibble::rownames_to_column(y_10_cpm, "ENST")
# Create CPM table with sample names
y_10_cpm %>% # Call data.
  pivot_longer(., # pivot table
               cols = starts_with("GSM"), # Pivot by GSM columns.
               names_to = "GSM", # Name new column to GSM
               values_to = "CPM") %>% # Assign values to CPM column
  left_join(., ref_geo_exp, by = "GSM") %>% # Match samples with type of affect.
  left_join(., ref_geo_genes, by = "ENST") %>% # Match ENST with genes.
  mutate(., Genes_CE = paste(Genes, "-", CE)) %>% # Add column of both affect and gene
  ggplot(., # Start ggplot
         aes(x = Genes_CE, y = CPM, fill = CE)) + # Assign variables 
  geom_boxplot() + # Create box plot.
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0         
    )) + 
  labs(title = sprintf("Figure 11: Log2(expr + 1) — Top 10 Differemtially Expressed Genes by Group"), # Title
       x = "Sample", y = "log2(expr + 1)",
       caption = str_wrap("Top 10 differentially expressed genes. The log2 of each expression grouped together by groups in boxplot. 1 was added to each expression value to avoid error."))
```

```{r Assign DEGs, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# edgeR results for p-value of 0.05
eres0.05 <- decideTests(lrt, p.value = 0.05, adjust.method = "fdr")
```

```{r Create excel of DEGs, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Create edgeR-full sheet.
lrt_sheet <- as.data.frame(topTags(lrt, n = Inf)) # Get statistical data
lrt_sheet <- rownames_to_column(lrt_sheet, var = "ensembl_transcript_id") # Assign ensembl_transcript_id as rownames' colname
lrt_sheet <- left_join(lrt_sheet, extra_data, by = "ensembl_transcript_id") # Join to description data
lrt_sheet <- lrt_sheet %>%
  dplyr::rename(symbol = external_gene_name) %>%
  dplyr::rename(genes = ensembl_transcript_id)
# Create DEGs.xlsx
sheets <- list("degs_sheet" = lrt_sheet)
write_xlsx(sheets, "Final_BIOS658_Stillman/Final_DEGs.xlsx")
# https://stackoverflow.com/questions/27713310/easy-way-to-export-multiple-data-frame-to-multiple-excel-worksheets
```

## Expression Visualization

The 9 most differential expressed protein coding genes visually appear to be distinct between individuals that have and have not been affected with COVID-19 (Figure 12). The relative expression of the top differential expressed genes are clearly based on the samples group (Figure 13). A volcano plot of expression reads shows that there are many signicanly expressed genes on a continuous scale (Figure 14). Some of the transcription read corresponded to the same gene, there average response was calculated and ploted (Figure 15), the results are similar to figure 14.   

```{r Set stats, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Set stats
p_val_cutoff   <- 0.05 # Regular p-value cutoff
p_adj_cutoff   <- 0.3 # FDR cutoff
nplot          <- 50 # How many genes to plot on a heatmap
nbox           <- 9  # How many genes to plot on a boxplot
ntable         <- 15 # Number of genes to output in a DEG table
nkegg          <- 35 # Number of genes to output in a KEGG table
col3 <- RColorBrewer::brewer.pal(20, "RdBu") # Create color palette
```

```{r Set up annotation, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
gene_annotations <- # Assign
lrt_sheet %>% # Load bioinfo data.
  dplyr::select(., ensembl_gene_id,  genes, symbol , gene_biotype, description) %>% # Select columns of interest
  dplyr::rename(ensgene = ensembl_gene_id,  enstgene = genes, symbol = symbol, biotype = gene_biotype) %>% # Rename columns to be more clear
  tidyr::drop_na() # Remove NAs
  
# Create sample annotation
sample_annotation <- data.frame(
  Sample = y$samples$title,
  Group = y$samples$COVID_EXP,
  Geo = y$samples$geo_accession
)
```

```{r Set up LRT sheet, echo=FALSE, message=FALSE, warning=FALSE}
# Isolate protein coding biotype
res <- lrt_sheet[lrt_sheet$gene_biotype == "protein_coding" & !is.na(lrt_sheet$gene_biotype), ]
# Select genes (ENSG) that meet res filters
selected_genes = unique(res$genes[!is.na(res$genes)])
# Get top 9 genes
genes_slice <- selected_genes[1:min(length(selected_genes), nbox)]
# Select genes and match order (using ensgene)
genes.to.plot <- res[res$genes %in% genes_slice, ]
# Get counts of genes of interest
matrix.to.plot <- counts[counts$enstgene %in% genes_slice, ]
# Reshape for ggplot
colnames(matrix.to.plot) <- c("Gene", y$samples$COVID_EXP)
matrix.to.plot_melted <- tidyr::pivot_longer(matrix.to.plot, cols = colnames(matrix.to.plot)[colnames(matrix.to.plot) != "Gene"]) # Pivot data for easier handling
matrix.to.plot_melted$Gene <- as.factor(matrix.to.plot_melted$Gene) # Turn gene into factors
# Plot
ggplot(matrix.to.plot_melted, aes(x = name, y = value, group = name)) + # X as names and y as value, group by name
  geom_boxplot(aes(fill = name)) + # Boxplot and fill by name
  facet_wrap(~ Gene, ncol = 3, scales = "free_y") + # Facet by gene
  labs(title = sprintf("Figure 12: Expression of Protein Coding mRNA"), # Title
       x = "Transcription IDs", y = "Counts",
       caption = str_wrap("The top 9 differentialy expressed transcripts are present in this box-plot The y-axis are the counts and the x-axis are the ensembl transcription IDs."), adj = 0.5)
```

```{r Heatmap3, echo=FALSE, results='hide', message=FALSE, warning=FALSE, fig.keep = "none"}
# Prepare genes to plot (top nplot)
genes.to.plot <- res[2:50, c("genes"), drop = FALSE] # Select genes to plot
# Create matrix of counts of genes of interest
matrix.to.plot <- counts[counts$enstgene %in% genes.to.plot$genes, ]
# Set row names to ENST
rownames(matrix.to.plot) <- matrix.to.plot$enstgene
# Remove ENST column
matrix.to.plot <- matrix.to.plot[ , 2:ncol(matrix.to.plot)]
# Create a dataframe that links symbols to ENST
ENST_TO_SYMBOL <- 
  lrt_sheet %>%
  dplyr::select(., genes, symbol)
# Translate ENST to symbols
ENST_df <- data.frame(genes = rownames(matrix.to.plot))
ENST_df <- left_join(ENST_df, ENST_TO_SYMBOL, by = "genes")
# Give matrix counts symbols as row names
matrix.to.plot <- matrix.to.plot[!duplicated(ENST_df$symbol),]
ENST_df <- ENST_df[!duplicated(ENST_df$symbol),]
rownames(matrix.to.plot) <- ENST_df$symbol
# Make group names rownames
annotation_col <- data.frame(Group = y$samples$COVID_EXP)
rownames(annotation_col) <- y$samples$title
# Plot heatmap
two <- pheatmap(matrix.to.plot, 
         color = colorRampPalette(c("navy", "white", "firebrick3"))(100), # Assumed col3 equivalent
         clustering_method = "ward", # Cluster method
         treeheight_row = FALSE, # No cluster tree
         treeheight_col = FALSE, # No cluster tree
         annotation_col = annotation_col, # Set annotation
         labels_row = genes.to.plot$symbol, # Lables for row set to gene symbols
         scale = "row",
         main = "Figure 13: Expression of Top 48 Genes for Each Sample",
         fontsize_row = 5, fontsize_col = 5) # Set scale to row
```

```{r Heatmap4, echo=FALSE, message=FALSE, warning=FALSE}
my_caption <- textGrob(str_wrap("Heat map of relative gene expression between the various samples. The  Ward's method was used to calculate clustering."),
                       gp = gpar(fontsize = 9, fontface = "italic"),
                       just = "left", x = 0.05)
grid.arrange(
    grobs = list(two[[4]], my_caption), # two[[4]] is the main heatmap grob
    heights = c(1, 0.1), # Adjust as needed (e.g., 1 for plot, 0.1 for caption)
    ncol = 1
)
# google(pheatmap r caption)
```


```{r Expression volcano plot, echo=FALSE, message=FALSE, warning=FALSE}
# use the function -- add_regulate to add a regulate column 
# to the DEG result data. 
res$FDR <- as.numeric(res$FDR)
data <- add_regulate(data = res, log2FC_name = "logFC",
                     fdr_name = "FDR", log2FC = 1, fdr = 0.3)
data <- na.omit(data)


gradual_volcano(data, x = "log2FoldChange", y = "padj", # Data and axises
          label = "symbol", label_number = 10, # Name top ten genes
          fills = c("#53a4cf", "#aec5d1", "white", "#e2ae96", "#cc917c", "#a96d5d", "#91403e"), # Set scale of colors
          colors = "#404950", # Outline color for points
          log2FC_cut = 0, # Log2FC cut off
          FDR_cut = 1, # FDR cut off
          add_line = FALSE, # No add line
          pointSizeRange = c(2, 2)) + # Size of points
  ggtitle("Figure 14: Volcano Plot of Transcript Expression Data") +
  theme(plot.title = element_text(hjust = 0.5), plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0         
    )) +
  labs(caption = str_wrap("Volcano plot of transcript expression levels. The top ten differentially expressed transcripts are labeled."))

```

```{r gene volcano plot, echo=FALSE, message=FALSE, warning=FALSE}
# Select symbol, logfc, and pvalue from lrt_sheet
lrt_sheet_g <- lrt_sheet[, c("symbol", "logFC", "PValue")]
# Calculate mean logFC for symbols
lrt_sheet_g1 <-
  lrt_sheet_g %>%
  group_by(., symbol) %>%
  summarize(., Log2FC = mean(logFC))

# Find symbols that only occur once and put into their own dataframe
single_list <- c()
for (symbol in unique(lrt_sheet_g$symbol)) {
  s_count = length(which(lrt_sheet_g$symbol==symbol))
  if (s_count == 1) {
    single_list <- c(single_list, symbol)
  }
 else{} 
}
lrt_sheet_g0 <- lrt_sheet[, c("symbol", "PValue")]
lrt_sheet_g2 <- lrt_sheet_g0[lrt_sheet_g0$symbol %in% single_list, ]

# Find symbols that occur more than once and put into their own dataframe
double_list <- c()
for (symbol in unique(lrt_sheet_g$symbol)) {
  s_count = length(which(lrt_sheet_g$symbol==symbol))
  if (s_count > 1) {
    double_list <- c(double_list, symbol)
  }
 else{} 
}
lrt_sheet_g3 <- lrt_sheet_g0[lrt_sheet_g0$symbol %in% double_list, ]
# Calculate combined p-values
lrt_sheet_g3 <-
  lrt_sheet_g3 %>%
  group_by(., symbol) %>%
  summarize(., PValue = sumlog(PValue)$p)
# Combine all the p-values together.
lrt_sheet_g23 <- rbind(lrt_sheet_g2, lrt_sheet_g3)
# Join mean Log2FC and mean P-values
lrt_sheet_g4 <- left_join(lrt_sheet_g1, lrt_sheet_g23, by = "symbol")
# remove ""
lrt_sheet_g4 <- lrt_sheet_g4 %>%
  dplyr::filter(., symbol != "")
# Aadd FDR column
lrt_sheet_g4$FDR <- p.adjust(lrt_sheet_g4$PValue, method = "fdr")

# use the function -- add_regulate to add a regulate column 
# to the DEG result data. 
lrt_sheet_g4$FDR <- as.numeric(lrt_sheet_g4$FDR)
data1 <- add_regulate(data = lrt_sheet_g4, log2FC_name = "logFC",
                     fdr_name = "FDR", log2FC = 1, fdr = 0.3)
data1 <- na.omit(data)


gradual_volcano(data1, x = "log2FoldChange", y = "padj", # Data and axises
          label = "symbol", label_number = 10, # Name top ten genes
          fills = c("#53a4cf", "#aec5d1", "white", "#e2ae96", "#cc917c", "#a96d5d", "#91403e"), # Set scale of colors
          colors = "#404950", # Outline color for points
          log2FC_cut = 0, # Log2FC cut off
          FDR_cut = 1, # FDR cut off
          add_line = FALSE, # No add line
          pointSizeRange = c(2, 2)) + # Size of points
          ggtitle("Figure 15: Volcano Plot of Gene Expression Data") +
          theme(plot.title = element_text(hjust = 0.5), plot.caption = element_text(
            size = 10,      
            color = "black", 
            face = "italic",    
            hjust = 0         
          )) +
          labs(caption = str_wrap("Volcano plot of gene expression levels. The top ten differentially expressed genes are labeled."))
```

This data was analyzed with a previously studied(@1) and table 6 compares the original studies tag results with this analysis tag results. This analysis produced many more tags, this is probably due to the original study breaking the samples into biological groups (sex and age), were as this analysis used sex and age as covariants resulting in higher variability. This analysis agree with the same tags and their direction of the original study (table 6)    

```{r Compare source and analysis, echo=FALSE, message=FALSE, warning=FALSE}
url <- "https://static-content.springer.com/esm/art%3A10.1038%2Fs43587-022-00321-w/MediaObjects/43587_2022_321_MOESM3_ESM.xlsx"
# Destination file name
destfile <- "43587_2022_321_MOESM3_ESM.xlsx"
# Download the file
download.file(url, destfile, mode = "wb")
# Get data from research
research_data <- read_excel("43587_2022_321_MOESM3_ESM.xlsx", sheet = "S2a. COVID vs Control")
# Isolate adj.p-value below 0.05
research_data <- research_data[research_data$padj < 0.05, ]
# Isolate adj.p-value below 0.05
lrt_sheet_p0.05 <- lrt_sheet[lrt_sheet$FDR < 0.05,]
# Remove duplicates symbols
lrt_sheet_p0.05 <-
  lrt_sheet_p0.05 %>% 
  distinct(., symbol, .keep_all = TRUE)
research_data <- 
  research_data %>%
  distinct(., external_gene_name, .keep_all = TRUE)
# Length of data points
r_total <- length(research_data$external_gene_name)
m_total <- length(lrt_sheet_p0.05$symbol)
# Sum of matching
total_match <- sum(research_data$external_gene_name %in% lrt_sheet_p0.05$symbol)
# Sum of not matching
total_not_match <- sum(!(research_data$external_gene_name %in% lrt_sheet_p0.05$symbol))
# Length of data points
r_utotal <- length(research_data[research_data$log2FoldChange > 0,]$external_gene_name)
m_utotal <- length(lrt_sheet_p0.05[lrt_sheet_p0.05$logFC > 0,]$symbol)
# Sum of matching up degs
total_match_up <- sum(research_data[research_data$log2FoldChange > 0,]$external_gene_name %in% lrt_sheet_p0.05[lrt_sheet_p0.05$logFC > 0,]$symbol)
# Sum of not matching up degs
total_not_match_up <- sum(!(research_data[research_data$log2FoldChange > 0,]$external_gene_name %in% lrt_sheet_p0.05[lrt_sheet_p0.05$logFC > 0,]$symbol))
# Length of data points
r_dtotal <- length(research_data[research_data$log2FoldChange <= 0,]$external_gene_name)
m_dtotal <- length(lrt_sheet_p0.05[lrt_sheet_p0.05$logFC <= 0,]$symbol)
# Sum of matching down degs
total_match_down <- sum(research_data[research_data$log2FoldChange <= 0,]$external_gene_name %in% lrt_sheet_p0.05[lrt_sheet_p0.05$logFC <= 0,]$symbol)
# Sum of not matching down degs
total_not_match_down <- sum(!(research_data[research_data$log2FoldChange <= 0,]$external_gene_name %in% lrt_sheet_p0.05[lrt_sheet_p0.05$logFC <= 0,]$symbol))

compare_tags <- data.frame(Metric = c("Mavrikaki project's total tags", "Stillman project's total tags", "Matches of tags between projects",
                      "No matches of tags between projects", "Mavrikaki project's total Up tags", "Stillman project's total Up tags",
                      "Matches of up tags between projects", "No matches of up tags between projects", "Mavrikaki project's total down tags",
                      "Stillman project's total down tags", "Matches of down tags between projects", "No matches of down tags between projects"),
           Counts = c(r_total, m_total, total_match, total_not_match, r_utotal, m_utotal, total_match_up, total_not_match_up, r_dtotal,
                      m_dtotal, total_match_down, total_not_match_down))

knitr::kable(compare_tags, caption = "Table 6: Counts and Comparison between Source Study and Current Analysis")  %>% kable_styling(full_width = FALSE) %>% add_footnote( label = "*The data for this analysis was sourced from a different study with the first auther is Dr. Maria Mavrikaki. This chart compares that study's tag results with analysis tag results.*")
```



```{r stop, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
#Stop_now
```

## Functional Enrichment Analysis

### GSEA Plots

The GSEA plots (Figure 16 - 27) have the common trend of pathways associated with infection and immune response being enriched in frontal cortex samples that are from patients that previously had COVID-19. This suggest that even after infection the brain tissue is behaving like there is still an ongoing infection leading to possible health issues. 

```{r remove everything, echo=FALSE, message=FALSE, warning=FALSE}
rm(list = ls())
```


```{r libraries, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
library(readxl)
library(writexl)
library(enrichR) # install.packages("enrichR")
library(annotables) # devtools::install_github("stephenturner/annotables") Annotations of Ensembl IDs
library(clusterProfiler)
library(DOSE)
library(ggplot2)
library(HGNChelper) # for correcting gene names 
library(tidyverse)
library(msigdbr)
library(nichenetr)
library(enrichplot)
library(org.Mm.eg.db)
library(msigdb)
```

```{r settings, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Data
data_dir <- "Final_BIOS658_Stillman" # Working directory
# File to save all results of differential expression analysis
fileNameIn1   <- file.path(data_dir, "Final_DEGs.xlsx") 
degs_sheet <- "Control vs. Covid19"
# degs_sheet <- "2.p53mut_5Gy_vs_p53mut_noGy"
# degs_sheet <- "3.M54_L_vs_Ctrl_L"
# degs_sheet <- "4.M55_L_vs_Ctrl_L"
# degs_sheet <- "5.C231_HP_vs_C231_HD"
# degs_sheet <- "6.C231_LP_vs_C231_LD"


up_dn_separate <- FALSE # Whether to run KEGG separately on up- and downregulated genes. FALSE - do not distinguish directionality
p_val_cutoff   <- 0.05 # Regular p-value cutoff
FDR_cutoff     <- 0.3# FDR cutoff for DEGs
msigdb_all     <- FALSE # Use all MSigDb categories (TRUE), or c("C2", "C5", "H") (FALSE)
fileNameOut1 <- file.path(data_dir, paste0("results/GSEA2_", make.names(degs_sheet), ".xlsx"))
# Create output folder, if not exists
if (!dir.exists(file.path(data_dir, "results"))) dir.create(file.path(data_dir, "results"))

# Which pathway enrichment analysis to run
run_gsea <- TRUE # If TRUE, GSEA pathway enrichment analysis is run, otherwise, standard hypergeometric-based enrichment
min_kegg_genes <- 20 # Minimum number of genes to run enrichment analysis on
max_kegg_genes <- 2000 # Maximum number of genes to run enrichment analysis on
p_adj_cutoff   <- 1 # FDR cutoff for enrichment results
nperm          <- 1000 # Number of permutations (for GSEA)
num_gseaplots  <- 3 # Number of GSEA plots to plot
ntop_symbols   <- 24 # Number of top gene entries to annotate with symbols in entrez_to_symbols function (set to Inf to annotate all)
```

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Mutually exclusive selectors, which analysis should be run. Only one may be TRUE
human_analysis <- TRUE
mouse_analysis <- FALSE

# Bioconductor setup (if needed):
# if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# BiocManager::install(c("AnnotationHub", "ensembldb", "org.Hs.eg.db", "org.Mm.eg.db"))

suppressPackageStartupMessages({
  library(AnnotationHub)
  library(ensembldb)
  library(AnnotationDbi)
  library(dplyr)
  library(tibble)
})

# Helper to get the latest EnsDb for a species/build from AnnotationHub
get_latest_EnsDb <- function(species, genome) {
  ah <- AnnotationHub::AnnotationHub()
  q <- AnnotationHub::query(ah, c("EnsDb", species, genome))
  if (length(q) == 0L) stop("No EnsDb found for: ", species, " ", genome)
  q[[which.max(as.Date(mcols(q)$rdatadateadded))]]
}

# Helper to build gene annotations and lengths
build_gene_data <- function(ensdb, orgdb, canonical_chrs, species_code, kegg_set, msigdbr_org) {
  # Pull genes with required columns from EnsDb
  g <- genes(
    ensdb,
    columns = c("gene_id", "gene_name", "gene_biotype", "seq_name",
                "gene_seq_start", "gene_seq_end")
  )
  df <- as_tibble(g) %>%
    transmute(
      ensgene = gene_id,
      symbol = gene_name,
      biotype = gene_biotype,
      chr = as.character(seqnames),
      start = as.integer(start),
      end = as.integer(end)
    ) %>%
    dplyr::filter(chr %in% canonical_chrs)

  # Map description (GENENAME) and ENTREZID from org.*.eg.db using ENSEMBL keys
  desc_map <- AnnotationDbi::select(
    orgdb,
    keys = unique(df$ensgene),
    keytype = "ENSEMBL",
    columns = c("GENENAME", "ENTREZID")
  ) %>%
    dplyr::rename(ensgene = ENSEMBL, description = GENENAME, entrezid = ENTREZID)

  df <- df %>%
    left_join(desc_map, by = "ensgene")

  # Final gene_annotations: protein_coding, non-NA symbol/description
  gene_annotations <- df %>%
    # dplyr::filter(
      # biotype == "protein_coding",
      # !is.na(symbol),
      # !is.na(description),
      # description != ""
    # ) %>%
    distinct(ensgene, symbol, biotype, description, entrezid, .keep_all = FALSE)

  # Gene length as gene span (end - start)
  gene_length <- df %>%
    transmute(Geneid = ensgene, Length = end - start) %>%
    distinct()

  # Background symbols
  all.symbol <- unique(gene_annotations$symbol)

  list(
    gene_annotations = gene_annotations,
    gene_length = gene_length,
    all.symbol = all.symbol,
    OrgDb = orgdb,
    species = species_code,
    KEGG = kegg_set,
    msigdbr_org = msigdbr_org
  )
}

# Flags controlling which species to process
# Set these as needed:
# human_analysis <- TRUE
# mouse_analysis <- FALSE

if (exists("human_analysis") && isTRUE(human_analysis)) {
  suppressPackageStartupMessages(library(org.Hs.eg.db))

  # EnsDb for human GRCh38 (change to "GRCh37" if you need that build)
  edb_hs <- get_latest_EnsDb("Homo sapiens", "GRCh38")

  human <- build_gene_data(
    ensdb = edb_hs,
    orgdb = org.Hs.eg.db,
    canonical_chrs = c(as.character(1:22), "X", "Y", "MT"),
    species_code = "hsa",
    kegg_set = "KEGG_2019_Human",
    msigdbr_org = "Homo sapiens"
  )

  gene_annotations <- human$gene_annotations
  gene_length <- human$gene_length
  all.symbol <- human$all.symbol
  OrgDb <- "org.Hs.eg.db"
  species <- "hsa"
  KEGG <- human$KEGG
  msigdbr_org <- human$msigdbr_org
}

if (exists("mouse_analysis") && isTRUE(mouse_analysis)) {
  suppressPackageStartupMessages(library(org.Mm.eg.db))

  # EnsDb for mouse GRCm38 (switch to "GRCm39" for the latest)
  edb_mm <- get_latest_EnsDb("Mus musculus", "GRCm38")

  mouse <- build_gene_data(
    ensdb = edb_mm,
    orgdb = org.Mm.eg.db,
    canonical_chrs = c(as.character(1:19), "X", "Y", "MT"),
    species_code = "mmu",
    kegg_set = "KEGG_2019_Mouse",
    msigdbr_org = "Mus musculus"
  )

  gene_annotations <- mouse$gene_annotations
  gene_length <- mouse$gene_length
  all.symbol <- mouse$all.symbol
  OrgDb <- "org.Mm.eg.db"
  species <- "mmu"
  KEGG <- mouse$KEGG
  msigdbr_org <- mouse$msigdbr_org
}

# Result objects:
# - gene_annotations: tibble with columns ensgene, symbol, biotype, description, entrezid
# - gene_length: data.frame/tibble with columns Geneid, Length
# - all.symbol: unique symbols vector
```


```{r eval=FALSE, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Mutually exclusive selectors, which analysis should be run. Only one may be TRUE
human_analysis <- TRUE
mouse_analysis <- FALSE

# Prepate gene annotations, remove non-canonical chromosome names
if (human_analysis) {
  library(org.Hs.eg.db)
  OrgDb = "org.Hs.eg.db"; species = "hsa"
  gene_annotations <- grch38[ !(grepl("_", grch38$chr) | grepl("GL", grch38$chr)), c("ensgene", "symbol", "biotype", "description")]
  gene_annotations <- gene_annotations[ !duplicated(gene_annotations) & !is.na(gene_annotations$symbol) & gene_annotations$description != "" & gene_annotations$biotype == "protein_coding", ]
  KEGG <- "KEGG_2019_Human"
  msigdbr_org <- "Homo sapiens"
  # Gene length for TPM calculations
  gene_length <- data.frame(Geneid = grch38$ensgene, Length = grch38$end - grch38$start)
}
if (mouse_analysis) {
  library(org.Mm.eg.db)
  OrgDb = "org.Mm.eg.db"; species = "mmu"
  gene_annotations <- grcm38[ !(grepl("_", grcm38$chr) | grepl("GL", grcm38$chr)), c("ensgene", "symbol", "biotype", "description")]
  gene_annotations <- gene_annotations[ !duplicated(gene_annotations) & !is.na(gene_annotations$symbol) & gene_annotations$description != "" & gene_annotations$biotype == "protein_coding", ]
  KEGG <- "KEGG_2019_Mouse"
  msigdbr_org <- "Mus musculus"
  # Gene length for TPM calculations
  gene_length <- data.frame(Geneid = grcm38$ensgene, Length = grcm38$end - grcm38$start)
}
# All genes for background
all.symbol <- unique(gene_annotations$symbol) 
```

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
mtx <- read_xlsx(fileNameIn1, sheet = "degs_sheet")
res <- data.frame(symbol = mtx$symbol, logFC = mtx$logFC, p.val = mtx$PValue, p.adj = mtx$FDR)
res <- res[ order(res$p.val, decreasing = FALSE), ]
# fix gene names 
# current_map <- getCurrentHumanMap()
# genes_checked <- checkGeneSymbols(res$symbol, map = current_map)
# res$symbol <- genes_checked$Suggested.Symbol
# Convert gene names for other organisms
# if (!human_analysis & mouse_analysis) {
#   res$symbol <- nichenetr::convert_mouse_to_human_symbols(res$symbol)
#   res <- res[!is.na(res$symbol), ]
#   res <- res[order(res$p.val, decreasing = FALSE), ]
# }
```

```{r hyper_kegg, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
kegg_enrich <- function(compartment_genes, p_adj_cutoff = p_adj_cutoff) {
  # stop if min_kegg is not met 
  stopifnot(length(compartment_genes) >= min_kegg_genes)
  res.kegg <- enrichr(unique(compartment_genes), databases = KEGG) # KEGG results only
  # If significant results are present, save them
  if (nrow(res.kegg[[KEGG]]) > 0 & sum(res.kegg[[KEGG]]$Adjusted.P.value < p_adj_cutoff) > 0) {
    res.kegg <- as.data.frame(res.kegg[[KEGG]])
    res.kegg <- res.kegg[res.kegg$Adjusted.P.value < p_adj_cutoff, , drop = FALSE]
    compartment_genes <- res.kegg
    # reorder the genes alphabetically 
    compartment_genes <- compartment_genes %>% 
      # separate the rows by splitting by the delimiter and expanding the rows 
      separate_rows(Genes, convert = TRUE, sep = ";") %>% 
      # group the genes by their Term & other columns to keep them 
      group_by(Term, Overlap, P.value, Adjusted.P.value, Old.P.value, Old.Adjusted.P.value,
               Odds.Ratio, Combined.Score) %>% 
      # sort the genes for each term 
      arrange(Genes) %>% 
      summarise(Genes = paste(Genes, collapse="/")) %>% 
      arrange(P.value, Adjusted.P.value)
  } else {
    compartment_genes <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 9))
    colnames(compartment_genes) <- c("Term", "Overlap", "P.value", "Adjusted.P.value", "Old.P.value", "Old.Adjusted.P.value", "Odds.Ratio", "Combined.Score", "Genes")
    compartment_genes$`P.value` = 0
    compartment_genes$`Adjusted.P.value` = 0
    compartment_genes$`Old.P.value` = 0
    compartment_genes$`Old.Adjusted.P.value` = 0
    compartment_genes$`Odds.Ratio` = 0
    compartment_genes$`Combined.Score` = 0
  }
  return(compartment_genes)
}

# run unranked KEGG analysis 
websiteLive <- TRUE # Check if EnrichR is up
  dbs <- listEnrichrDbs()
  if (is.null(dbs)) websiteLive <- FALSE
  if(websiteLive) {
    # Subset the number of DEGs for KEGG analysis to the maximum
    if (nrow(res[res$p.val < p_val_cutoff, ]) > max_kegg_genes) {
      degs_subset <- res[1:max_kegg_genes, ]
    } else {
      degs_subset <- res[res$p.adj < FDR_cutoff, ]
    }
    # Get list of up- and downregulated genes
    up.genes <- sort(unique(degs_subset$symbol[ degs_subset$logFC > 0 ]))
    dn.genes <- sort(unique(degs_subset$symbol[ degs_subset$logFC < 0 ]))
    res.kegg  <- NULL # Initially, empty value
    # if process up and down regulated genes separately 
    if (up_dn_separate) {
      # run unranked KEGG on up and down regulated genes separately 
      print(paste0("KEGG pathway run on ", length(up.genes), " upregulated and ",
                   length(dn.genes), " downregulated genes."))
      res.kegg.up <- kegg_enrich(up.genes, p_adj_cutoff = p_adj_cutoff) %>%
        dplyr::mutate(Direction = "UP") # add new Direction column 
      res.kegg.dn <- kegg_enrich(dn.genes, p_adj_cutoff = p_adj_cutoff) %>%
        dplyr::mutate(Direction = "DN") # add new Direction column 
      res.kegg = rbind(res.kegg.up, res.kegg.dn)
      res.kegg <- res.kegg[order(res.kegg$P.value), ]
    } else {
      # run the up regulated and down regulated genes together 
      print(paste0("KEGG pathway run on ", length(unique(c(up.genes, dn.genes))),
                   " genes without distinguishing them by directionality."))
      # run hypergeomtric KEGG analysis on combination of genes 
      res.kegg <- kegg_enrich(unique(c(up.genes, dn.genes)), 
                              p_adj_cutoff = p_adj_cutoff)
    }
  }
```

```{r hyper_msig, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Convert Entrez IDs to symbols using gene_annotations object
# This function uses the gene_annotations tibble that contains entrezid-to-symbol mappings
#
# @param entrez_list Character vector of slash-separated EntrezID strings
# @param gene_annotations Tibble with columns entrezid and symbol for mapping
# @param ntop Number of entries to process (default: 24)
# @return Character vector with EntrezIDs converted to gene symbols
entrez_to_symbols <- function(entrez_list, gene_annotations, ntop = 24) {
  # Create a fast lookup table (named vector) from entrezid to symbol
  # Filter out NA entrezids, keep first occurrence per entrezid for O(1) hash-based lookups
  entrez_map_df <- gene_annotations %>%
    dplyr::filter(!is.na(entrezid)) %>%
    dplyr::distinct(entrezid, symbol)
  entrez_lookup <- setNames(entrez_map_df$symbol, entrez_map_df$entrezid)
  
  # Function to convert a single slash-separated string
  convert_single <- function(entrez_string) {
    entrez_ids <- unlist(strsplit(entrez_string, "/"))
    # Use named vector indexing for O(1) lookup with proper NA handling
    matched_symbols <- entrez_lookup[entrez_ids]
    symbols <- ifelse(is.na(matched_symbols), entrez_ids, matched_symbols)
    # Sort alphabetically for consistent output across runs
    paste(sort(symbols), collapse = "/")
  }
  
  # Initialize result as original input
  result <- entrez_list
  
  # Process top ntop entries (if ntop is Inf, process all entries)
  n_to_process <- if (is.infinite(ntop)) length(entrez_list) else min(ntop, length(entrez_list))
  result[1:n_to_process] <- vapply(entrez_list[1:n_to_process], convert_single, character(1))
  
  return(result)
}


# Get unique categories
if (msigdb_all) {
  m_df <- msigdbr(species = msigdbr_org)
  m_df_gs_cat <- unique(m_df$gs_collection) %>% sort()
} else {
  # Use most informative ones
  m_df_gs_cat <- c("C2", "C5", "H")
}

# Function to perform enrichment analysis using MSigDb signatures
msigdb_enrich <- function(dataset, p_adj_cutoff = p_adj_cutoff) {
  # Top DEGs for enrichr
  # res.all <- dataset[dataset$p.val < p_val_cutoff, ]
      # Subset the number of DEGs for KEGG analysis to the maximum
    if (nrow(dataset[dataset$p.val < p_val_cutoff, ]) > max_kegg_genes) {
      res.all <- dataset[1:max_kegg_genes, ]
    } else {
      res.all <- dataset[dataset$p.adj < p_val_cutoff, ]
    }
  # Convert symbols to entrezids
  eid <- bitr(res.all$symbol, fromType="SYMBOL", toType="ENTREZID", OrgDb=OrgDb)
  # Attach converted entrezids
  res.all <- left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[ !is.na(res.all$ENTREZID), ]
  # List of t-statistics
  geneList_significant <- res.all$logFC
  # Make it named
  names(geneList_significant) <- res.all$ENTREZID
  # And decreasing sorted
  geneList_significant <- sort(geneList_significant, decreasing = TRUE)
  res.msigdf.all <- list()
  # gs_cat="C2" # For testing
  for (gs_cat in m_df_gs_cat) {
    # Term to gene
     m_t2g <- msigdbr(species = msigdbr_org, collection = gs_cat) %>% 
       dplyr::distinct(gs_name, ncbi_gene)
    # Term to description 
    m_t2d <- msigdbr(species = msigdbr_org, collection = gs_cat) %>% 
       dplyr::distinct(gs_name, gs_description)
    # Enrichment analysis
    if (up_dn_separate) {
      # run unranked MSigDb on up and down regulated genes separately 
      print(paste0("MSigDb run on ", length(geneList_significant[geneList_significant > 0]), " upregulated and ",
                   length(geneList_significant[geneList_significant < 0]), " downregulated genes."))
      # Upregulated genes
      em.up <- enricher(names(geneList_significant[geneList_significant > 0]), TERM2GENE=m_t2g, pvalueCutoff = p_adj_cutoff)
      if (!is.null(em.up)) {
        if (!any(is.na(em.up@result$qvalue))) {
          em.up@result <- em.up@result %>% dplyr::mutate(Direction = "UP") # add new Direction column 
        } else {
          em.up <- NULL
        }
      }
      # Downregulated genes
      em.dn <- enricher(names(geneList_significant[geneList_significant < 0]), TERM2GENE=m_t2g, pvalueCutoff = p_adj_cutoff)
      if (!is.null(em.dn)) {
        if (!any(is.na(em.dn@result$qvalue))) {
          em.dn@result <- em.dn@result %>% dplyr::mutate(Direction = "DN") # add new Direction column 
        } else {
          em.dn <- NULL
        }
      }
      #  # Check if the results are non-empty
      if (!(is.null(em.up) | is.null(em.dn))) {
        res.msigdf.em <- rbind(em.up@result, em.dn@result)
        res.msigdf.em <- res.msigdf.em[res.msigdf.em$p.adjust < p_adj_cutoff, , drop = FALSE]
        res.msigdf.em$core_enrichment <- entrez_to_symbols(res.msigdf.em$geneID, gene_annotations, ntop = ntop_symbols)
        # sort the genes alphabetically
        res.msigdf.em <- res.msigdf.em %>% 
          # separate the rows by splitting by the delimiter and expanding the rows 
          separate_rows(geneID, convert = TRUE, sep = "/") %>% 
          # group the genes by their other columns to keep them 
          group_by(ID, Description, GeneRatio, BgRatio, pvalue, p.adjust, qvalue, Count, core_enrichment, Direction, core_enrichment) %>%
          # sort the genes for each term 
          arrange(geneID) %>% 
          summarise(geneID = paste(geneID, collapse="/")) %>% 
          arrange(pvalue, p.adjust)
        # Append description
        res.msigdf.em <- left_join(res.msigdf.em, m_t2d, by = c("ID" = "gs_name"))
        res.msigdf.em$Description <- res.msigdf.em$gs_description
        res.msigdf.em$gs_description <- NULL
        res.msigdf.em$geneID <- NULL
      } else {
        res.msigdf.em <- as.data.frame(matrix(data = "Nothing significant", nrow = 1,
                                              ncol = 10))
        colnames(res.msigdf.em) <- c("ID", "Description", "GeneRatio", "BgRatio",
                                     "pvalue", "p.adjust", "qvalue", "geneID", "Count", "Direction")
      }
    } else {
      # All genes
      em <- enricher(names(geneList_significant), TERM2GENE=m_t2g, pvalueCutoff = p_adj_cutoff)
      if (!is.null(em) | !any(is.na(em@result$qvalue))) {
        em@result <- em@result %>% dplyr::mutate(Direction = "ALL") # add new Direction column 
      }
      #  # Check if the results are non-empty
      if (!(is.null(em))) {
        res.msigdf.em <- rbind(em@result)
        res.msigdf.em <- res.msigdf.em[res.msigdf.em$p.adjust < p_adj_cutoff, , drop = FALSE]
        res.msigdf.em$core_enrichment <- entrez_to_symbols(res.msigdf.em$geneID, gene_annotations, ntop = ntop_symbols)
        # sort the genes alphabetically
        res.msigdf.em <- res.msigdf.em %>% 
          # separate the rows by splitting by the delimiter and expanding the rows 
          separate_rows(geneID, convert = TRUE, sep = "/") %>% 
          # group the genes by their other columns to keep them 
          group_by(ID, Description, GeneRatio, BgRatio, pvalue, p.adjust, qvalue, Count, Direction, core_enrichment) %>%
          # sort the genes for each term 
          arrange(geneID) %>% 
          summarise(geneID = paste(geneID, collapse="/")) %>% 
          arrange(pvalue, p.adjust)
        # Append description
        res.msigdf.em <- left_join(res.msigdf.em, m_t2d, by = c("ID" = "gs_name"))
        res.msigdf.em$Description <- res.msigdf.em$gs_description
        res.msigdf.em$gs_description <- NULL
      } else {
        res.msigdf.em <- as.data.frame(matrix(data = "Nothing significant", nrow = 1,
                                              ncol = 10))
        colnames(res.msigdf.em) <- c("ID", "Description", "GeneRatio", "BgRatio",
                                     "pvalue", "p.adjust", "qvalue", "geneID", "Count", "Direction")
      }
    }
    # Combine the results and add names
    res.msigdf.all <- c(res.msigdf.all, list(res.msigdf.em))
    names(res.msigdf.all)[length(res.msigdf.all)] <- paste0("Enrich.", gs_cat)
  }
  res.msigdf.all
}
# run unranked MSigDb analysis 
res.msigdb.enrich <- msigdb_enrich(dataset = res, p_adj_cutoff = p_adj_cutoff)
```

```{r gsea.kegg, eval=FALSE, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Function to perform GSEA analysis on KEGG
gsea_kegg_enrich <- function(dataset, p_adj_cutoff = p_adj_cutoff) {
  # All DEGs for GSEA
  # res.all <- dataset
  res.all <- dataset %>%
  group_by(symbol) %>%
  slice_max(order_by = abs(logFC), n = 1, with_ties = FALSE) %>%
  ungroup()
  # Convert symbols to entrezids
  eid <- bitr(unique(res.all$symbol), fromType="SYMBOL", toType="ENTREZID", OrgDb=OrgDb)
  # Attach converted entrezids
  res.all <- left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[ !is.na(res.all$ENTREZID), ]
  # List of t-statistics
  geneList <- res.all$logFC
  # Make it named
  names(geneList) <- res.all$ENTREZID
  # And decreasing sorted
  geneList <- sort(geneList, decreasing = TRUE)

  # Actual GSEA
  set.seed(1)
  ego3 <- gseKEGG(geneList     = geneList,
                  organism     = species,
                  # nPerm        = nperm,
                  minGSSize    = 10,
                  pvalueCutoff = 1,
                  verbose      = FALSE)
  # Get summary
  ego3 <- setReadable(ego3, OrgDb = OrgDb, keyType = "ENTREZID")
  res.kegg.gsea <- as.data.frame(ego3)
  # Process if non-empty
  if( nrow(res.kegg.gsea) > 0) {
    # Prepare for table output
  res.kegg.gsea <- res.kegg.gsea[, c("ID", "Description", "NES", "pvalue", "p.adjust", "core_enrichment")]
  # reorder the genes alphabetically 
    res.kegg.gsea <- res.kegg.gsea %>% 
      # separate the rows by splitting by the delimiter and expanding the rows 
      separate_rows(core_enrichment, convert = TRUE, sep = "/") %>% 
      # group the genes by their ID & other columns to keep them 
      group_by(ID, Description, NES, pvalue, p.adjust) %>% 
      # sort the genes for each term 
      arrange(core_enrichment) %>% 
      # now collapse them again so they will be sorted alphabetically 
      summarise(core_enrichment = paste(core_enrichment, collapse="/"))
    
    res.kegg.gsea <- res.kegg.gsea[order(abs(res.kegg.gsea$NES), decreasing = TRUE), ]
    res.kegg.gsea <- res.kegg.gsea[res.kegg.gsea$p.adjust < p_adj_cutoff, ]
    res.kegg.gsea$NES       <- round(res.kegg.gsea$NES, digits = 2)
    res.kegg.gsea$pvalue    <- formatC(res.kegg.gsea$pvalue, format = "e", digits = 2)
    res.kegg.gsea$p.adjust  <- formatC(res.kegg.gsea$p.adjust, format = "e", digits = 2)
    rownames(res.kegg.gsea) <- NULL
  } else {
    res.kegg.gsea <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 6))
    colnames(res.kegg.gsea) <- c("ID", "Description", "NES", "pvalue", "p.adjust", "core_enrichment")
  }
  return(res.kegg.gsea)
}

# run GSEA KEGG analysis 
res.kegg.gsea <- gsea_kegg_enrich(res, p_adj_cutoff = p_adj_cutoff)
```

```{r gsea.kegg2, echo=FALSE, message=FALSE, warning=FALSE}
# Function to perform GSEA analysis on KEGG (returns ego3, the gseaResult object)
gsea_kegg_enrich <- function(dataset = res, p_adj_cutoff = 0.05) {
  res.all <- dataset %>%
    dplyr::group_by(symbol) %>%
    dplyr::slice_max(order_by = abs(logFC), n = 1, with_ties = FALSE) %>%
    dplyr::ungroup()
  eid <- bitr(unique(res.all$symbol), fromType = "SYMBOL", toType = "ENTREZID", OrgDb = OrgDb)
  res.all <- dplyr::left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[!is.na(res.all$ENTREZID), ]
  geneList <- res.all$logFC
  names(geneList) <- res.all$ENTREZID
  geneList <- sort(geneList, decreasing = TRUE)
  set.seed(1)
  ego3 <- gseKEGG(
    geneList     = geneList,
    organism     = species,
    minGSSize    = 10,
    pvalueCutoff = 1,
    verbose      = FALSE
  )
  ego3 <- setReadable(ego3, OrgDb = OrgDb, keyType = "ENTREZID")
  return(ego3)
}

res.kegg.ego3 <- gsea_kegg_enrich(res, p_adj_cutoff = p_adj_cutoff)

# Function to reformat gseaResult object into processed data frame
gsea_kegg_results_to_df <- function(ego3, p_adj_cutoff = 0.05) {
  res.kegg.gsea <- as.data.frame(ego3)
  if (nrow(res.kegg.gsea) > 0) {
    res.kegg.gsea <- res.kegg.gsea[, c("ID", "Description", "NES", "pvalue", "p.adjust", "core_enrichment")]
    res.kegg.gsea <- res.kegg.gsea %>%
      tidyr::separate_rows(core_enrichment, convert = TRUE, sep = "/") %>%
      dplyr::group_by(ID, Description, NES, pvalue, p.adjust) %>%
      dplyr::arrange(core_enrichment) %>%
      dplyr::summarise(core_enrichment = paste(core_enrichment, collapse = "/"), .groups = "drop")
    res.kegg.gsea <- res.kegg.gsea[order(abs(res.kegg.gsea$NES), decreasing = TRUE), ]
    res.kegg.gsea <- res.kegg.gsea[res.kegg.gsea$p.adjust < p_adj_cutoff, ]
    res.kegg.gsea$NES       <- round(res.kegg.gsea$NES, digits = 2)
    res.kegg.gsea$pvalue    <- formatC(res.kegg.gsea$pvalue, format = "e", digits = 2)
    res.kegg.gsea$p.adjust  <- formatC(res.kegg.gsea$p.adjust, format = "e", digits = 2)
    rownames(res.kegg.gsea) <- NULL
  } else {
    res.kegg.gsea <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 6))
    colnames(res.kegg.gsea) <- c("ID", "Description", "NES", "pvalue", "p.adjust", "core_enrichment")
  }
  return(res.kegg.gsea)
}

res.kegg.gsea <- gsea_kegg_results_to_df(res.kegg.ego3, p_adj_cutoff = p_adj_cutoff)

plot_disc <- c("Expression enrichment to reponses to staphylococcus aureus infection as illustrated by the GSEA plot.",
               "Expression enrichment characterized in complement and coagulation cascades illustrated by the GSEA plot.",
               "Expression enrichment to reponses to leishmaniasis infection as illustrated by the GSEA plot.")

# Plot the top enriched pathways
for (i in 1:num_gseaplots) {
  pathway_id <- res.kegg.gsea$ID[i]
  pathway_desc <- res.kegg.gsea$Description[i]
  print(gseaplot2(res.kegg.ego3, geneSetID = pathway_id, title = paste0("Figure ", as.character(i+15), ": ", pathway_desc)))
  cat(plot_disc[i])
}
```

```{r gsea.msig, eval=FALSE, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Function to perform GSEA analysis using MSigDb signatures
gsea_msigdb_enrich <- function(dataset, p_adj_cutoff = p_adj_cutoff) {
  res.all <- dataset %>%
  group_by(symbol) %>%
  slice_max(order_by = abs(logFC), n = 1, with_ties = FALSE) %>%
  ungroup()
  # Convert symbols to entrezids
  eid <- bitr(res.all$symbol, fromType="SYMBOL", toType="ENTREZID", OrgDb=OrgDb)
  # Attach converted entrezids
  res.all <- left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[ !is.na(res.all$ENTREZID), ]
  # List of t-statistics
  geneList <- res.all$logFC
  # Make it named
  names(geneList) <- res.all$ENTREZID
  # And decreasing sorted
  geneList <- sort(geneList, decreasing = TRUE)
  # Actual MSIGDB
  res.msigdf.all <- list()
  # gs_cat="H" # For testing
  for (gs_cat in m_df_gs_cat) {
    # Term to gene
     m_t2g <- msigdbr(species = msigdbr_org, collection = gs_cat) %>% 
       dplyr::distinct(gs_name, ncbi_gene)
    # Term to description 
    m_t2d <- msigdbr(species = msigdbr_org, collection = gs_cat) %>% 
       dplyr::distinct(gs_name, gs_description)
    # Enrichment analysis
    em2 <- GSEA(geneList, TERM2GENE = m_t2g, pvalueCutoff = p_adj_cutoff)
    # Check if the results are non-empty
    if (nrow(em2@result) > 0) {
      res.msigdf.em2 <- em2@result
      res.msigdf.em2$core_enrichment <- entrez_to_symbols(res.msigdf.em2$core_enrichment, gene_annotations, ntop = ntop_symbols)
      # sort the genes alphabetically
      res.msigdf.em2 <- res.msigdf.em2 %>% 
      # separate the rows by splitting by the delimiter and expanding the rows 
      separate_rows(core_enrichment, convert = TRUE, sep = "/") %>% 
      # group the genes by their other columns to keep them 
      group_by(ID, Description, setSize, enrichmentScore, NES, pvalue, p.adjust, qvalue,
               rank, leading_edge) %>%
      # sort the genes for each term 
      arrange(core_enrichment) %>% 
      summarise(core_enrichment = paste(core_enrichment, collapse="/")) %>% 
      arrange(pvalue, p.adjust) 
      # Append description
      res.msigdf.em2 <- left_join(res.msigdf.em2, m_t2d, by = c("ID" = "gs_name"))
      res.msigdf.em2$Description <- res.msigdf.em2$gs_description
      res.msigdf.em2$gs_description <- NULL
    } else {
      res.msigdf.em2 <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 11))
      colnames(res.msigdf.em2) <- c("ID", "Description", "setSize", "enrichmentScore", "NES", "pvalue", "p.adjust", "qvalues", "rank", "leading_edge", "core_enrichment")
      # res.msigdf.em2 <- res.msigdf.em2 %>% # drop unneeded columns
      # dplyr::filter(-c(setSize, enrichmentScore, qvalues, rank, leading_edge))
    }
    
    res.msigdf.all <- c(res.msigdf.all, list(res.msigdf.em2))
    names(res.msigdf.all)[length(res.msigdf.all) - 0] <- paste0("GSEA.", gs_cat)
  }
  return(res.msigdf.all)
}

# call GSEA MSigDb
res.msigdb <- c(res.msigdb, gsea_msigdb_enrich(res, p_adj_cutoff = p_adj_cutoff))
```

```{r gsea.msig2, echo=FALSE, message=FALSE, warning=FALSE}
# Function to perform GSEA analysis using MSigDb signatures
gsea_msigdb_enrich <- function(dataset, p_adj_cutoff = 0.05) {
  # Preprocess dataset: get the most significant gene per symbol
  res.all <- dataset %>%
    dplyr::group_by(symbol) %>%
    dplyr::slice_max(order_by = abs(logFC), n = 1, with_ties = FALSE) %>%
    dplyr::ungroup()
  # Convert gene symbols to entrez IDs
  eid <- bitr(res.all$symbol, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = OrgDb)
  res.all <- dplyr::left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[!is.na(res.all$ENTREZID), ]
  # Named gene list
  geneList <- res.all$logFC
  names(geneList) <- res.all$ENTREZID
  geneList <- sort(geneList, decreasing = TRUE)
  # GSEA for each MSigDB category
  res.msigdb.all <- list()
  for (gs_cat in m_df_gs_cat) {
    m_t2g <- msigdbr(species = msigdbr_org, collection = gs_cat) %>%
      dplyr::distinct(gs_name, ncbi_gene)
    em2 <- GSEA(geneList, TERM2GENE = m_t2g, pvalueCutoff = p_adj_cutoff)
    res.msigdb.all[[paste0("GSEA.", gs_cat)]] <- em2
  }
  return(res.msigdb.all)
}

res.msigdb.em2 <- gsea_msigdb_enrich(res, p_adj_cutoff = p_adj_cutoff)
  
  
# Function to reformat a list of GSEA results into a list of data frames
gsea_msigdb_results_to_df <- function(res.msigdb.all, gene_annotations, msigdbr_org) {
  res.msigdf.all <- list()
  for (nm in names(res.msigdb.all)) {
    em2 <- res.msigdb.all[[nm]]
    # Term to description 
    res.msigdf.em2 <- NULL
    if (nrow(em2@result) > 0) {
      gs_cat <- sub("GSEA.", "", nm)
      m_t2d <- msigdbr(species = msigdbr_org, collection = gs_cat) %>%
        dplyr::distinct(gs_name, gs_description)
      res.msigdf.em2 <- em2@result
      res.msigdf.em2$core_enrichment <- entrez_to_symbols(res.msigdf.em2$core_enrichment, gene_annotations, ntop = ntop_symbols)
      res.msigdf.em2 <- res.msigdf.em2 %>%
        tidyr::separate_rows(core_enrichment, convert = TRUE, sep = "/") %>%
        dplyr::group_by(ID, Description, setSize, enrichmentScore, NES, pvalue, p.adjust, qvalue,
                        rank, leading_edge) %>%
        dplyr::arrange(core_enrichment) %>%
        dplyr::summarise(core_enrichment = paste(core_enrichment, collapse = "/"), .groups = "drop") %>%
        dplyr::arrange(pvalue, p.adjust)
      # Append description
      res.msigdf.em2 <- dplyr::left_join(res.msigdf.em2, m_t2d, by = c("ID" = "gs_name"))
      res.msigdf.em2$Description <- res.msigdf.em2$gs_description
      res.msigdf.em2$gs_description <- NULL
    } else {
      res.msigdf.em2 <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 11))
      colnames(res.msigdf.em2) <- c("ID", "Description", "setSize", "enrichmentScore", "NES", "pvalue", "p.adjust", "qvalues", "rank", "leading_edge", "core_enrichment")
    }
    res.msigdf.all[[nm]] <- res.msigdf.em2
  }
  return(res.msigdf.all)
}

res.msigdb <- gsea_msigdb_results_to_df(res.msigdb.all = res.msigdb.em2, gene_annotations = gene_annotations, msigdbr_org = msigdbr_org)

# Plot the top enriched pathways
plot_disc <- c("'Genes up-regulated in pulpal tissue extracted from carious teeth' (GSEA (2025)).",
          "'Age up-regulated genes in the human frontal cortex' (GSEA (2025)).",
          "'Inflammatory cytokines, chemokines and their cognate receptors up-regulated in THP-1 cells (monocyte) after treatment with PSMD4' (GSEA (2025))."
          )
  
  
for (catname in names(res.msigdb.em2)[1]) {
  gsea_res <- res.msigdb.em2[[catname]]
  gsea_df <- as.data.frame(gsea_res)
  for (i in seq_len(min(num_gseaplots, nrow(gsea_df)))) {
    pathway_id <- gsea_df$ID[i]
    pathway_desc <- gsea_df$Description[i]
    print(
      gseaplot2(
        gsea_res,
        geneSetID = pathway_id,
        title = paste0("Figure", as.character(i+18), ": ", catname, ": ", pathway_desc)
      )
    )
    cat(plot_disc[i])
  }
}

plot_disc <- c("'An immune response mediated through a body fluid' (GSEA (2025)).",
          "'Any process that stops, prevents, or reduces the frequency, rate, or extent of an immune effector process' (GSEA (2025)).",
          "'Any process that activates or increases the frequency, rate or extent of the inflammatory response' (GSEA (2025))."
          )

for (catname in names(res.msigdb.em2)[2]) {
  gsea_res <- res.msigdb.em2[[catname]]
  gsea_df <- as.data.frame(gsea_res)
  for (i in seq_len(min(num_gseaplots, nrow(gsea_df)))) {
    pathway_id <- gsea_df$ID[i]
    pathway_desc <- gsea_df$Description[i]
    print(
      gseaplot2(
        gsea_res,
        geneSetID = pathway_id,
        title = paste0("Figure", as.character(i+21), ": ", catname, ": ", pathway_desc)
      )
    )
    cat(plot_disc[i])
  }
}

plot_disc <- c("'Genes up-regulated by IL6 [GeneID=3569] via STAT3 [GeneID=6774], e.g., during acute phase response' (GSEA (2025)).",
          "'Genes up-regulated in response to IFNG [GeneID=3458]' (GSEA (2025)).",
          "'Genes up-regulated in response to alpha interferon proteins' (GSEA (2025)).")

for (catname in names(res.msigdb.em2)[3]) {
  gsea_res <- res.msigdb.em2[[catname]]
  gsea_df <- as.data.frame(gsea_res)
  for (i in seq_len(min(num_gseaplots, nrow(gsea_df)))) {
    pathway_id <- gsea_df$ID[i]
    pathway_desc <- gsea_df$Description[i]
    print(
      gseaplot2(
        gsea_res,
        geneSetID = pathway_id,
        title = paste0("Figure ", as.character(i+24), ": ", catname, ": ", pathway_desc)
      )
    )
    cat(plot_disc[i])
  }
}
```

### MSigDB gene sets

The analysis of enriched pathways in MSigDB gene sets (Figure 28 - 35) has a few worrying results. The trend of evaluated immune and infection response continues, but with the add detection of enrichment in pathways associated with seizures and other brain ailments. This enforces that COVID-19 infection has long term consequences on brain health.    

```{r msig_combine, eval=FALSE, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# empty list to hold results from unranked MSigDb and GSEA MSigDb in order grouped by enrichment category 
res.msigdf.all <- list()

# iterate through length of each list of dataframes, doesn't matter which 
for (i in 1:length(names(res.msigdb))) {
  # add unranked MsigDB results first 
  res.msigdf.all[[length(res.msigdf.all) + 1]] = res.msigdb[[i]]
  names(res.msigdf.all)[[length(res.msigdf.all)]] = names(res.msigdb[i])
  # # add GSEA MsigDB next 
  # res.msigdf.all[[length(res.msigdf.all)+1]] = res.msigdb.gsea[[i]]
  # names(res.msigdf.all)[[length(res.msigdf.all)]] = names(res.msigdb.gsea[i])
}
```

```{r msig_combine2, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Interleave two named lists of the same length
interleave_lists <- function(list1, list2) {
  n <- length(list1)
  if (length(list2) != n) stop("Lists must have the same length")
  names1 <- names(list1)
  names2 <- names(list2)
  out <- vector("list", 2 * n)
  out_names <- character(2 * n)
  out[seq(1, 2*n, by=2)] <- list1
  out[seq(2, 2*n, by=2)] <- list2
  out_names[seq(1, 2*n, by=2)] <- names1
  out_names[seq(2, 2*n, by=2)] <- names2
  names(out) <- out_names
  out
}

# Example usage:
res.msigdf.all <- interleave_lists(res.msigdb.enrich, res.msigdb)
```

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
x <- c(list(Enrich.KEGG = res.kegg), list(GSEA.KEGG = res.kegg.gsea), res.msigdf.all) # 
# names(x)[1:2] <- c("Enrich.KEGG", "GSEA.KEGG")
write_xlsx(x, path = fileNameOut1)
```

```{r eval=FALSE, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Create custom signatures for KEGG pathways
library(KEGGREST)
gs_cat <- "KEGG"
gs_selected <- "KEGG_Breast_cancer"
# Get numerical EntrezIDs
query <- keggGet("hsa05224")
query_gene <- query[[1]]$GENE[grepl("^[0-9]", query[[1]]$GENE, perl = TRUE)]
# The actual custom signature
m_t2g <- data.frame(gs_name = gs_selected, entrez_gene = query_gene)

# Use standard MSigDb sitnatures
gs_cat <- "C5"
gs_selected_all <- c("GOCC_CYTOSOLIC_RIBOSOME", "GOBP_DEFENSE_RESPONSE")

# For each signature
for (gs_selected in gs_selected_all) {
  print(gs_selected)
  # gs_selected <- "HALLMARK_DNA_REPAIR"
  # Do the enrichment analysis
  m_t2g <- msigdbr(species = "Homo sapiens", collection = gs_cat) %>% dplyr::distinct(gs_name, entrez_gene) %>% dplyr::filter(gs_name == !!gs_selected)
  em2 <- GSEA(geneList, TERM2GENE = m_t2g, pvalueCutoff = p_adj_cutoff)
  # Save the picture
  gseaplot(em2, geneSetID = 1, by = "runningScore")
  ggsave(filename = file.path(data_dir, paste0("results/Figure_GSEA_", gs_cat, "_", gs_selected, ".svg")), width = 4, height = 2.6, units = "in")
}
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Load library
library(dplyr)
# Create bar graph.
y <- # Assign to new variable
x[[1]] %>% # Get data. 
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 4]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = Term, x = neglog10.Adjusted.P.value, fill = Term)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 8,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + 
  ggtitle("Figure 28: Enrich.KEGG") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = str_wrap("The top 10 most significantly  enrich KEGG pathways without considering DEG order. The adjusted p-value has been scaled with -log10."))

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[2]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 7]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 8,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 29: GSEA.KEGG") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label 
  labs(caption = str_wrap("The top 10 most significantly  enrich GSEA KEGG pathways considering largest to smallest order of DEGs. The adjusted p-value has been scaled with -log10."))

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[3]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 8,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + 
  ggtitle("Figure 30: Enrich.C2") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = "The top 11 most significantly  enrich pathways without considering\nDEG order. Curated gene sets from online pathway databases,\npublicationsin PubMed, and knowledge of domain experts\n(Dozmorov (2025)). The adjusted p-value has been scaled with -log10.")

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[4]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        axis.text.x = element_text(size = 8),
        plot.caption = element_text(
          size = 8,      
          color = "black", 
          face = "italic",    
          hjust = 0 ),
        axis.text.y = element_text(size = 5)) + # remove legend
  ggtitle("Figure 31: GSEA.C2") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = "The top most significantly  enrich GSEA pathways considering largest to\nsmallest order of DEGs. Curated gene sets from online pathway\ndatabases, publications in PubMed, and knowledge of domain experts\n(Dozmorov (2025)). The adjusted p-value has been scaled with -log10.")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[5]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 8,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 32: Enrich.C5") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = str_wrap("The top most significantly  enrich pathways without considering DEG order. GO gene sets  consist of genes annotated by the same GO terms. (Dozmorov (2025)). The adjusted p-value has been scaled with -log10."))
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[6]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[11, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.

  scale_y_discrete(labels = function(x) {
    # Define the maximum number of characters
    max_chars <- 20
    
    # Truncate labels longer than max_chars and add "..."
    ifelse(nchar(x) > max_chars, paste0(substr(x, 1, max_chars), "..."), x)
  }) +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 8),
        plot.caption = element_text(
          size = 8,      
          color = "black", 
          face = "italic",    
          hjust = 0 ),
        axis.text.y = element_text(size = 5)) + # remove legend
  ggtitle("Figure 33: GSEA.C5") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  coord_cartesian(xlim = c(3, 7)) +
  labs(caption = str_wrap("The top most significantly  enrich GSEA pathways considering largest to smallest order of DEGs. GO gene sets  consist of genes annotated by the same GO terms. (Dozmorov (2025)). The adjusted p-value has been scaled with -log10."))

# google("r ggplot2 limit number of characters in y axis")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[7]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 8,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 34: Enrich.H") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
   labs(caption = "The top most significantly  enrich hallmark gene sets pathways\nwithout considering DEG order. The adjusted p-value has been scaled with\n-log10.")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[8]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 8,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 35: GSEA.H") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = "The top most significantly enrich GSEA hallmark gene sets pathways\n considering largest to smallest order of DEGs. The adjusted p-value\nhas been scaled with -log10.")
```

To check if the same pathways in this analysis and the original study findings are similar (@1), a key terms check was performed. Key terms of the originals study's results were search in this analysis pathway enrichment data to find overlap. This analysis did find enrichment in pathways associated in brain and brain function pathways, but not the mitochondrial pathway findings the original study obtained (Table 7). This is strong agreement on premature aging occuring in this analysis and the original study. 

```{r Terms of interest, echo=FALSE, message=FALSE, warning=FALSE}
# Terms of interest
key_terms <- c("synaptic", "cognition", "memory", "DNA damage", "mitochendrial", "mitochendria", "regulatory stress", "oxidative stress",
               "vesicular", "calcium homeostasis", "insulin", "aging", "age", "brain", "Synaptic", "Cognition", "Memory", "DNA damage",
               "Mitochendrial", "Mitochendria", "Regulatory stress", "Oxidative stress", "Vesicular", "Calcium homeostasis", "Insulin", 
               "Aging", "Age", "Brain")
# First data.frame
KEY_TERM_DF1 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF1 <- rbind(KEY_TERM_DF1, x[1]$Enrich.KEGG[grepl(term, x[1]$Enrich.KEGG$Term), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF1 <- KEY_TERM_DF1[as.numeric(KEY_TERM_DF1$Adjusted.P.value) < 0.05,]

# Look for key terms
# Second data.frame
KEY_TERM_DF2 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF2 <- rbind(KEY_TERM_DF2, x[[2]][grepl(term, x[[2]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF2 <- KEY_TERM_DF2[as.numeric(KEY_TERM_DF2$p.adjust) < 0.05,]

# Third data.frame
KEY_TERM_DF3 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF3 <- rbind(KEY_TERM_DF3, x[[3]][grepl(term, x[[3]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF3 <- KEY_TERM_DF3[as.numeric(KEY_TERM_DF3$p.adjust) < 0.05,]

# Forth data.frame
KEY_TERM_DF4 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF4 <- rbind(KEY_TERM_DF4, x[[4]][grepl(term, x[[4]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF4 <- KEY_TERM_DF4[as.numeric(KEY_TERM_DF4$p.adjust) < 0.05,]

# Fifth data.frame
KEY_TERM_DF5 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF5 <- rbind(KEY_TERM_DF5, x[[5]][grepl(term, x[[5]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF5 <- KEY_TERM_DF5[as.numeric(KEY_TERM_DF5$p.adjust) < 0.05,]

# Sixth data.frame  
KEY_TERM_DF6 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF6 <- rbind(KEY_TERM_DF6, x[[6]][grepl(term, x[[6]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF6 <- KEY_TERM_DF6[as.numeric(KEY_TERM_DF6$p.adjust) < 0.05,]

# Seventh data.frame
KEY_TERM_DF7 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF7 <- rbind(KEY_TERM_DF7, x[[7]][grepl(term, x[[7]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF7 <- KEY_TERM_DF7[as.numeric(KEY_TERM_DF7$p.adjust) < 0.05,]

# Eighth data.frame
KEY_TERM_DF8 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF8 <- rbind(KEY_TERM_DF8, x[[8]][grepl(term, x[[8]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF8 <- KEY_TERM_DF8[as.numeric(KEY_TERM_DF8$p.adjust) < 0.05,]
# List of descriptions
Term_check_list <- c(KEY_TERM_DF1$Term, KEY_TERM_DF2$Description, KEY_TERM_DF3$Description, KEY_TERM_DF4$Description,
                      KEY_TERM_DF5$Description, KEY_TERM_DF6$Description, KEY_TERM_DF7$Description, 
                     KEY_TERM_DF8$Description)
# Check if all terms met.
Count_of_term <- c()
for (term in key_terms) {
  sum_count <- (sum(grepl(term, Term_check_list)))
  Count_of_term <- c(Count_of_term, sum_count)
}
# Create key terms that are present
key_term_df <- data.frame(Terms = key_terms,
                          Counts = Count_of_term)
knitr::kable(key_term_df, caption = "Table 7: Count of Key Terms Functional Enrichment Analysis.") %>% kable_styling(full_width = FALSE) %>% add_footnote( label = "*Key terms were taken from the source study (Mavrikaki (2022)). These terms were searched for in the function enrichment analysis and counted.*")
```


# DISCUSSION

This analysis found that COVID-19 likely has long term health consequences on brain tissue. This appears to be driven by increased activity of inflammation pathways in the brain tissue leading to enrichment in pathways associated with brain disease, trauma, and aging. The overall results that this analysis came to is similar to the parent study, besides the mitochondrial findings and the numbers of Tags(@1). These difference can be attributed in the original study's use of biological groups while this analysis did not and chose to use biological differences in the samples as covariants in the analysis.


# COMPUTATIONAL COMPONENT



```{r Library1, eval=FALSE}
#Load libraries.
library(tximport)
library(Biobase)
library(SummarizedExperiment)
library(org.Hs.eg.db)
library(GEOquery)
library(stringr)
library(tidyr)
library(limma)
library("DESeq2")
library(ggVennDiagram)
library(biomaRt)
library(vsn)
library(tibble)
library(circlize)
library(knitr)
library(pander)
library(openxlsx)
library(writexl)
library(DT)
library(edgeR)
library(sva)
library(ggrepel)
library(reshape2)
library(plotly)
library(dplyr)
library(readr)
# library(MDmisc)
library(heatmaply)
# library(shiny)
library(ggplot2)
library(pheatmap)
# source("https://raw.githubusercontent.com/mdozmorov/enrichR/master/R/api_wrapper.R")
library(enrichR) # install.packages("enrichR")
# source("/Users/mdozmorov/Documents/Work/GitHub/RNA-seq/utils_NF.R")   # Helper functions
library(annotables) # devtools::install_github("stephenturner/annotables") Annotations of Ensembl IDs
library("ggsci")
library(scales)
library(metap)
library(ggVolcano)
 library(readxl)
library(gridExtra)
library(grid)
library(kableExtra)
library(stringr)
```


```{r Download data1, eval=FALSE}
# Retrieve experimantal data.
# Set directory.
dir <- "Final_BIOS658_Stillman"
setwd(dir)
# GSE ID.
GSE <- "GSE188847"
# URL of the GEO SOFT file
url <- "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE188847&format=file"
# Destination file name
destfile <- "GSE188847_RAW.tar"
# Download the file
download.file(url, destfile, mode = "wb")
# Check if the file exists
if (file.exists(destfile)) {
  message("Download complete: ", destfile)
} else {
  warning("Download failed!")
}
# Uncompress GSE188847_RAW.tar data.
untar(destfile, exdir = "GSE188847_RAW")
```

```{r Get GEO1, eval=FALSE}
# Download GEO GSE188847 series matrix.
gse <- getGEO("GSE188847", GSEMatrix = TRUE, destdir = dir)
```

```{r Unpack data1, eval=FALSE}
# List all .sf.txt folders in GSE188847_RAW. .sf.txt folders contain the .sf files.
files <- list.files("GSE188847_RAW",
                    pattern = ".gz$", full.names = TRUE)
# Optional: named vector with sample names. Strip files names down to sample name with gsub.This will transfer over to tximport.
# gsub perform replacement of the first and all matches respectively within each element of a character vector.
names(files) <- gsub("_.*", "", basename(files))
# Read Salmon files. Takes the .sf files in the file list and compiles them into a lists.
txi <- tximport(files, type = "salmon", txOut = TRUE)  # txOut=TRUE keeps transcript level
```

```{r geo vs txi check1, eval=FALSE}
# Extract GEO sample names.
geo_samples <- sampleNames(gse[[1]])
# Extract txi sample names.
txi_samples <- colnames(txi$counts)
# Check if they match
all(geo_samples %in% txi_samples)   # Should be TRUE
```

```{r Assign pheno. data1, eval=FALSE}
# Create colData from GEO phenoData. pData access phenotypic data from the GEO object.  
colData <- as.data.frame(pData(gse[[1]]))  # convert to data.frame
# Check if they match
all(geo_samples %in% rownames(colData))   # Should be TRUE
# Assign geo_sample (sample names) to the row names of colData.
rownames(colData) <- geo_samples          # ensure rownames match columns
```

```{r Get Counts from txi1, eval=FALSE}
# Extract gene counts from txi object. Counts is raw counts. 
txi_counts <- txi$counts[, geo_samples]
# Extract TPM from txi object. Abundance is the quantification of expression levels.
txi_tpm <- txi$abundance[, geo_samples]
```

```{r Create SummarizedExperiment1, eval=FALSE}
# Create the SummarizedExperiment. Combine counts, TPM, and ColData. Now the phenotype and gene expression can be compared.
se <- SummarizedExperiment(
  assays = list(
    counts = txi_counts,
    TPM    = txi_tpm
  ),
  colData = colData
)
# Look at summarized Experiment.
se
```

```{r Remove ID versions1, eval=FALSE}
# Remove ID versions from the gene IDs with gsub.
# https://stackoverflow.com/questions/23413331/how-to-remove-last-n-characters-from-every-element-in-the-r-vector
se@NAMES <- gsub("\\..*", '', se@NAMES)
```

```{r Retrieve ensembl1, eval=FALSE}
# Connect to Ensembl
ensembl <- useMart("ensembl")
# Human pattern
human_datasets <- listDatasets(ensembl)
# Assign human pattern.
human_dataset <- human_datasets[human_datasets$dataset == "hsapiens_gene_ensembl",]
# Connect to the chosen human dataset
ensembl_h <- useMart("ensembl", dataset = human_dataset$dataset)

# Create data template with orders
extra_data <- as.data.frame(se@NAMES) # Assign nsembl_transcript_id
colnames(extra_data) <- "ensembl_transcript_id" # Give column name
c_order <- as.data.frame(1:nrow(extra_data)) # Assign order
colnames(c_order) <- "order" # Get column name
extra_data <- cbind(extra_data, c_order) # bind together.

# Use getBM to get human "ensembl_transcript_id", "external_gene_name", "ensembl_gene_id", and "description"
h <- # Assign
  getBM( # Start getBM
  attributes = c("ensembl_transcript_id", "external_gene_name", "ensembl_gene_id", "description", "gene_biotype"), # Information to get
  filters = "ensembl_transcript_id", # filter by "ensembl_transcript_id"
  values = se@NAMES, # Use names
  mart = ensembl_h # What ensembl to use
)  
 
# Merge the getBM data to the extra data template fill in blanks of getBM data
extra_data <- merge(x = extra_data, y = h, by = "ensembl_transcript_id", all.x =TRUE)
# Order the data
extra_data_order <- extra_data[order(extra_data$order),]
# Remove order.
extra_data <-
  extra_data %>%
  dplyr::select(., -order)

# Google
# https://www.biostars.org/p/66529/
# https://stackoverflow.com/questions/17878048/merge-two-data-frames-while-keeping-the-original-row-order
```

```{r Isolate covid and control samples1, eval=FALSE}
# Create new dataframe that contains samples that have had covid.
COVID_cells <- se@colData@listData$title[grepl("COVID",se@colData@listData$title)]
# Create new dataframe that contains samples that have not had covid.
Control_cells <- se@colData@listData$title[grepl("CONTROL",se@colData@listData$title)]
# Create se of covid and control samples
COVID_Control_cells <- c(COVID_cells, Control_cells) # Create list of control and covid samples
T_cells <- se@colData@listData$title %in% COVID_Control_cells # Boolean of samples in se
se_COVID_Control_cells <- se[,T_cells] # Isolate control and covid samples in se
```

```{r Create affected variable1, eval=FALSE}
# Assign affected and unaffected groups 
COVID_EXP <- ifelse(grepl("COVID", se_COVID_Control_cells@colData@listData$title), "Affected", "Unaffected")
se_COVID_Control_cells@colData@listData$COVID_EXP <- COVID_EXP
# Assign affected and unaffected groups factor
COVID_EXP_F <- ifelse(grepl("COVID", se_COVID_Control_cells@colData@listData$title), 1, 0)
se_COVID_Control_cells@colData@listData$COVID_EXP_F <- factor(COVID_EXP_F)
```

```{r edgeR normalization1, eval=FALSE}
# Adjusut data
# Turn se_COVID_Control_cells into a DGEList.
y <- SE2DGEList(se_COVID_Control_cells )
# Order samples.
o <- order(rowSums(y$counts), decreasing = TRUE)
# Order samples by counts
y <- y[o,]
# Identify duplicates.
d <- duplicated(rownames(y$counts))
# Remove duplicates from DGEList
y <- y[!d,]
# Number of rows after processing
nrow(y)
# Filter out low expressions
keep <- filterByExpr(y)
y <- y[keep, keep.lib.sizes = FALSE]
# Recompute the library sizes.
y$samples$lib.size <- colSums(y$counts)
# TMM normalization is applied to this dataset to account for compositional difference between the libraries.
y <- normLibSizes(y)
# Look at normal factor.
y$samples$norm.factors
```

```{r Visualize Correlation before SVA1, eval=FALSE}
# Create link between sample name and affect
ref_title_exp <- data.frame(Sample = y$samples$title,
                          group = y$samples$COVID_EXP)
# Log of counts before SVA
log2_mat <- log2(y$counts + 1)
# Replace Colnames with Sample names
colnames(log2_mat) <- y$samples$title
# Adjust data to be used in box plot
df_sva_b <- # Assign
  log2_mat %>% # Get log2_mat
  as.data.frame() %>% # Turn to data.frame
  tibble::rownames_to_column("ENST") %>% # Turn ENST column into rownames.
  pivot_longer( # Pivot data by sample names
    cols = -ENST,
    names_to = "Sample",
    values_to = "log2expr"
  ) %>%
  left_join(., ref_title_exp, by = "Sample") # Joint samples to group
# Visualize boxplots after no SVA correction
ggplot(df_sva_b, aes(x = Sample, y = log2expr, fill = group)) + # start ggplot
  geom_boxplot(outlier.size = 0.3) + # Start boxplot
  scale_fill_brewer(palette = "Set2") + # Set palette for scale
  theme_bw() + # black and white theme
  theme(
    axis.text.x = element_blank(),   # remove sample labels
    axis.ticks.x = element_blank(),   # remove ticks if you also want them gone
    plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0         
    )) +
  labs(title = sprintf("Figure 1: Log2(expr + 1) — Before SVA correction"), # Title
       x = "Sample", y = "log2(expr + 1)",
       caption = str_wrap("The log2 of each expression grouped together by groups in boxplot. 1 was added to each expression value to avoid error."))
```
\
\
```{r Sample annotation11, eval=FALSE}
# Create sample annotation
sample_annotation <- data.frame(
  Sample = y$samples$title,
  Group = y$samples$COVID_EXP,
  Geo = y$samples$geo_accession
)
```
\
\
```{r Sum of Counts1, eval=FALSE}
# Get count data
counts <- y$counts
# Rename columns with sample names
colnames(counts) <- y$samples$title
# Check to see if share sample names
#all.equal(sample_annotation$Sample, colnames(counts))
# Turn counts into datafame
counts <- data.frame(counts)
# Create gene columns
counts <- # Assign to self
  counts %>% # Call data
  tibble::rownames_to_column(., "enstgene") # Make ENST rownames into column
# Calculate column-wise sums for samples (excluding Geneid)
sample_sums <- colSums(counts[, -1])  
# Create a data frame with sums and merge with the sample annotation
sample_sums_df <- data.frame(Sample = names(sample_sums), Sum = sample_sums)
# Combine Sample, sum, and group into one dataframe
sample_sums_annotated <- merge(sample_sums_df, sample_annotation, by = "Sample")  
# Order by the sum of counts
sample_sums_annotated <- sample_sums_annotated[order(sample_sums_annotated$Sum), ]
# Create a bar plot of treatment and sum counts
ggplot(sample_sums_annotated, aes(x = reorder(Sample, Sum), y = Sum, fill = Group)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  coord_flip() +
  labs(x = "Sample", y = "Sum of Counts", title = "Figure 2: Sum of Counts by Sample before SVA Correction",
       caption = str_wrap("The sum of expression counts was calculated for each samples and displayed.")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.caption = element_text(
          size = 10,       
          color = "black", 
          face = "italic",  
          hjust = 0))

```
\
\
```{r Sample annotation21, eval=FALSE}
my_caption <- textGrob(str_wrap("The  Interaction Analysis by Chi-Square (IAC) was calculated bewteen each sample before SVA correction for the top 10% of\n variable genes. This is map on the above heatmap with cluster designation"),
                       gp = gpar(fontsize = 9, fontface = "italic"),
                       just = "left", x = 0.05)
# Create matrix of couunts
mtx <- cpm(y$counts, normalized.lib.sizes = TRUE)
# set column names to sample names
colnames(mtx) <- y$samples$title
# The function varFilter removes features exhibiting little variation across samples. Such non-specific filtering can be advantageous for downstream data analysis.
# https://www.rdocumentation.org/packages/methylumi/versions/2.18.2/topics/varFilter
mtx_to_plot <- varFilter(mtx, var.cutoff = 0.9)
# IAC sample association.
IAC <- mtx_to_plot %>% cor(. , use = "pairwise.complete.obs",  method = "pearson") 
# Create dataframe of groups.
plot_annotations <- data.frame(Group = y$samples$COVID_EXP)
# Combine groups and treatments
rownames(plot_annotations) <- y$samples$title
# Create heat and cluster map of association.
one <- pheatmap(IAC, annotation_col = plot_annotations, clustering_method = "ward.D", main = "Figure 3: IAC Heat Map before SVA Correction", fontsize_row = 5, fontsize_col = 5)
```

```{r heat grid1, eval=FALSE}
grid.arrange(
    grobs = list(one[[4]], my_caption), # one[[4]] is the main heatmap grob
    heights = c(1, 0.1), # Adjust as needed (e.g., 1 for plot, 0.1 for caption)
    ncol = 1
)
# google(pheatmap r caption)
```
\
\
```{r PCA plot11, eval=FALSE}
# PCA: Check for batch effects. Select one batch, to color points by its assignment
pca <-  mtx_to_plot %>% t  %>% scale %>% prcomp
# Look at the statistic of PC
pca_df <- data.frame(summary(pca)$importance)[, 1:min(5, ncol(summary(pca)$importance))] # Percent of variance explained
knitr::kable(round(pca_df, 3), caption = "Table 1: Summary of PCA results before SVA correction") %>% add_footnote( label = "*The expression counts were put through Principal Component Analysis. The results are summarized above.*")
colorby <- "Group" # covariates[2]
# Create cluster group graph
pt <- ggplot(data = data.frame(pca$x, sample_annotation, samples = sample_annotation$Sample, stringsAsFactors = F), # Use data set projected on the PC as the data.
             aes(x = as.numeric(PC1), y = as.numeric(PC2), label = samples)) + # Set x as PC1 and y as PC2.
  theme(plot.title = element_text(lineheight = 0.8, face="bold"),  plot.caption = element_text(
          size = 10,       
          color = "black", 
          face = "italic",  
          hjust = 0)) + # Select theme.
  ggtitle("Figure 4: PCA of Samples Before SVA Correction") + # Put in title
  geom_point(aes(color = eval(parse(text = colorby))), size = 3) + # Create point graph
  geom_text_repel(colour = "black", size = 3) + # Give each point a color
  geom_hline(yintercept = 0, colour = "gray65") + # Set hor. line color
  geom_vline(xintercept = 0, colour = "gray65") + # Set ver. line color
  labs(color = colorby, caption = str_wrap("The expression counts were put through Principal Component Analysis. The two most prominent PC are set as axises and the samples are plotted on them to illustrate relationship.")) + # Set labels by groups
  scale_x_continuous(name = paste0("PC1, ", round(summary(pca)$importance[2,1] * 100, digits = 2), "% variability" )) + # Set scale for x
  scale_y_continuous(name = paste0("PC2, ", round(summary(pca)$importance[2,2] * 100, digits = 2), "% variability" )) # Set scale for y
plot(pt) # Plot
# https://stackoverflow.com/questions/33710240/how-to-attach-a-title-to-a-data-frame-in-rr
```

```{r SVA13, eval=FALSE}
# SVA: estimate surrogate variables and remove their effects
# Prepare data and design matrices for svaseq
dat_for_sva <- as.matrix(y$counts)  
# Assign affected variable.
EXP_F <- y$samples$COVID_EXP_F
# Assign ages
age_v <- as.integer(y$samples$age.ch1)
# Assign sex.
sex_v <- y$samples$Sex.ch1
sex_f <- ifelse(sex_v == "M", 0, 1)
sex_f <- factor(sex_f)
# Create models for SVA
mod = model.matrix(~EXP_F + age_v + sex_f) # Model with biological charactristics of interest
mod0 <- cbind(mod[,1])  # null model (intercept-only)
# Estimate number of surrogate variables automatically (Leek method)
n.sv <- num.sv(dat_for_sva, mod, method = "leek")
cat("Estimated number of surrogate variables:", n.sv, "\n")
# Run svaseq to estimate surrogate variables
svseq <- svaseq(dat = dat_for_sva, mod = mod, mod0 = mod0, n.sv = n.sv-1)
# Remove surrogate variable effects using limma::removeBatchEffect (treat sv's as covariates)
sv_mat <- svseq$sv
sva_corrected <- limma::removeBatchEffect(dat_for_sva, covariates = sv_mat)
# Create link between sample name and affect
ref_geo_exp <- data.frame(Sample = y$samples$geo_accession,
                          group = y$samples$COVID_EXP)
# Create link between sample name and affect
ref_title_exp <- data.frame(Sample = y$samples$title,
                          group = y$samples$COVID_EXP)
```


```{r SVA11, eval=FALSE}
# Replace negative values with 0
sva_corrected[sva_corrected <= 0] = 0
# Visualize boxplots after SVA correction
sva_corrected_log2 <- log2(sva_corrected + 1)
# Change columns to sample names
colnames(sva_corrected_log2) <- y$samples$title
# Remove all negatice numbers
sva_corrected_log2[is.na(sva_corrected_log2)] = 0
# Adjust data to be used in box plot
df_sva <- # Assign
  sva_corrected_log2 %>% # Get log2 data
  as.data.frame() %>% # Turn into data frame
  tibble::rownames_to_column("ENST") %>% # Turn ENST column into rownames
  pivot_longer( # Pivot data on samples
    cols = -ENST,
    names_to = "Sample",
    values_to = "log2expr"
  ) %>%
  left_join(., ref_title_exp, by = "Sample") # Join group to data
```

```{r Library Size1, eval=FALSE}
cat("Library size was", sum(se_COVID_Control_cells@assays@data$counts), "before normalization / SVA correction and is now", sum(sva_corrected), "after SVA correction." )
```

```{r Assign SVA counts to main data1, eval=FALSE}
dim(y$counts)
dim(sva_corrected)
y$counts[1]
sva_corrected[1]
# Assign SVA corrected counts to y
y$counts <- sva_corrected
```

```{r Sample Annotation31, eval=FALSE}
# Create sample annotation
sample_annotation <- data.frame(
  Sample = y$samples$title,
  Group = y$samples$COVID_EXP,
  Geo = y$samples$geo_accession
)
```

```{r Visualize Correlation after SVA1, eval=FALSE}
# Create link between sample name and affect
ref_title_exp <- data.frame(Sample = y$samples$title,
                          group = y$samples$COVID_EXP)
# Log of counts before SVA
log2_mat <- log2(y$counts + 1)
# Replace Colnames with Sample names
colnames(log2_mat) <- y$samples$title
# Adjust data to be used in box plot
df_sva_b <- # Assign
  log2_mat %>% # Get log2_mat
  as.data.frame() %>% # Turn to data.frame
  tibble::rownames_to_column("ENST") %>% # Turn ENST column into rownames.
  pivot_longer( # Pivot data by sample names
    cols = -ENST,
    names_to = "Sample",
    values_to = "log2expr"
  ) %>%
  left_join(., ref_title_exp, by = "Sample") # Joint samples to group
# Visualize boxplots after no SVA correction
ggplot(df_sva_b, aes(x = Sample, y = log2expr, fill = group)) + # start ggplot
  geom_boxplot(outlier.size = 0.3) + # Start boxplot
  scale_fill_brewer(palette = "Set2") + # Set palette for scale
  theme_bw() + # black and white theme
  theme(
    axis.text.x = element_blank(),   # remove sample labels
    axis.ticks.x = element_blank(),   # remove ticks if you also want them gone
    plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0         
    )) +
  labs(title = sprintf("Figure 5: Log2(expr + 1) — After SVA correction"), # Title
       x = "Sample", y = "log2(expr + 1)",
       caption = str_wrap("The log2 of each expression grouped together by groups in boxplot. 1 was added to each expression value to avoid error."))
```

```{r Sum of Counts21, eval=FALSE}
# Get count data
counts <- y$counts
# Rename columns with sample names
colnames(counts) <- y$samples$title
# Check to see if share sample names
#all.equal(sample_annotation$Sample, colnames(counts))
# Turn counts into datafame
counts <- data.frame(counts)
# Create gene columns
counts <- # Assign to self
  counts %>% # Call data
  tibble::rownames_to_column(., "enstgene") # Make ENST rownames into column
# Calculate column-wise sums for samples (excluding Geneid)
sample_sums <- colSums(counts[, -1])  
# Create a data frame with sums and merge with the sample annotation
sample_sums_df <- data.frame(Sample = names(sample_sums), Sum = sample_sums)
# Combine Sample, sum, and group into one dataframe
sample_sums_annotated <- merge(sample_sums_df, sample_annotation, by = "Sample")  
# Order by the sum of counts
sample_sums_annotated <- sample_sums_annotated[order(sample_sums_annotated$Sum), ]
# Create a bar plot of treatment and sum counts
ggplot(sample_sums_annotated, aes(x = reorder(Sample, Sum), y = Sum, fill = Group)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  coord_flip() +
  labs(x = "Sample", y = "Sum of Counts", title = "Figure 6: Sum of Counts by Sample After SVA Correction",
       caption = str_wrap("The sum of expression counts was calculated for each samples and displayed.")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        plot.caption = element_text(
          size = 10,       
          color = "black", 
          face = "italic",  
          hjust = 0))

```

```{r Sample annotation41, eval=FALSE}
my_caption <- textGrob(str_wrap("The  Interaction Analysis by Chi-Square (IAC) was calculated bewteen each sample after SVA correction for the top 10% of\n variable genes. This is map on the above heatmap with cluster designation"),
                       gp = gpar(fontsize = 9, fontface = "italic"),
                       just = "left", x = 0.05)
# Create matrix of couunts
mtx <- cpm(y$counts, normalized.lib.sizes = TRUE)
# set column names to sample names
colnames(mtx) <- y$samples$title
# The function varFilter removes features exhibiting little variation across samples. Such non-specific filtering can be advantageous for downstream data analysis.
# https://www.rdocumentation.org/packages/methylumi/versions/2.18.2/topics/varFilter
mtx_to_plot <- varFilter(mtx, var.cutoff = 0.9)
# IAC sample association.
IAC <- mtx_to_plot %>% cor(. , use = "pairwise.complete.obs",  method = "pearson") 
# Create dataframe of groups.
plot_annotations <- data.frame(Group = y$samples$COVID_EXP)
# Combine groups and treatments
rownames(plot_annotations) <- y$samples$title
# Create heat and cluster map of association.
one <- pheatmap(IAC, annotation_col = plot_annotations, clustering_method = "ward.D", main = "Figure 7: IAC Heat Map After SVA Correction", fontsize_row = 5, fontsize_col = 5)
```

```{r heat map21, eval=FALSE}
grid.arrange(
    grobs = list(one[[4]], my_caption), # one[[4]] is the main heatmap grob
    heights = c(1, 0.1), # Adjust as needed (e.g., 1 for plot, 0.1 for caption)
    ncol = 1
)
# google(pheatmap r caption)
```
\
\
```{r PCA plot21, eval=FALSE}
# PCA: Check for batch effects. Select one batch, to color points by its assignment
pca <-  mtx_to_plot %>% t  %>% scale %>% prcomp
# Look at the statistic of PC
pca_df <- data.frame(summary(pca)$importance)[, 1:min(5, ncol(summary(pca)$importance))] # Percent of variance explained
knitr::kable(round(pca_df, 3), caption = "Table 2: Summary of PCA results After SVA correction") %>% add_footnote( label = "*The expression counts were put through Principal Component Analysis. The results are summarized above.*")
colorby <- "Group" # covariates[2]
# Create cluster group graph
pt <- ggplot(data = data.frame(pca$x, sample_annotation, samples = sample_annotation$Sample, stringsAsFactors = F), # Use data set projected on the PC as the data.
             aes(x = as.numeric(PC1), y = as.numeric(PC2), label = samples)) + # Set x as PC1 and y as PC2.
  theme(plot.title = element_text(lineheight = 0.8, face="bold"),  plot.caption = element_text(
          size = 10,       
          color = "black", 
          face = "italic",  
          hjust = 0)) + # Select theme.
  ggtitle("Figure 8: PCA of Samples After SVA Correction") + # Put in title
  geom_point(aes(color = eval(parse(text = colorby))), size = 3) + # Create point graph
  geom_text_repel(colour = "black", size = 3) + # Give each point a color
  geom_hline(yintercept = 0, colour = "gray65") + # Set hor. line color
  geom_vline(xintercept = 0, colour = "gray65") + # Set ver. line color
  labs(color = colorby, caption = str_wrap("The expression counts were put through Principal Component Analysis. The two most prominent PC are set as axises and the samples are plotted on them to illustrate relationship.")) + # Set labels by groups
  scale_x_continuous(name = paste0("PC1, ", round(summary(pca)$importance[2,1] * 100, digits = 2), "% variability" )) + # Set scale for x
  scale_y_continuous(name = paste0("PC2, ", round(summary(pca)$importance[2,2] * 100, digits = 2), "% variability" )) # Set scale for y
plot(pt) # Plot
# https://stackoverflow.com/questions/33710240/how-to-attach-a-title-to-a-data-frame-in-rr
```

```{r Creating design1, eval=FALSE}
# Assign affected variable.
EXP_F <- y$samples$COVID_EXP_F
# Assign ages
age_v <- as.integer(y$samples$age.ch1)
# Assign sex.
sex_v <- y$samples$Sex.ch1
sex_f <- ifelse(sex_v == "M", 0, 1)
sex_f <- factor(sex_f)
# Create design that compares unaffected and affected.
design <- model.matrix(~EXP_F + age_v + sex_f)
# Assign row names to design based on variable y.
rownames(design) <- colnames(y)
# Inspect design.
head(design)
# Estimate dispersion of y data based on deign.
y <- estimateDisp(y, design, robust=TRUE)
# Extract common dispersion.
y$common.dispersion
```

```{r, eval=FALSE}
# Plot the BCV.
plotBCV(y) +
  title("Figure 9: BCV Plot of Expression")  +
  title(sub = str_wrap("The x-axis is the average log2 of CPM and the y-axis is the genewise biological coefficient of variation (BCV). This is done to illustrate the common trend of the tagwise, further emphasized by the common and trend line"), adj = 0.5, line = 6) 
# google("r caption below plotBCV plot")
# https://www.rdocumentation.org/packages/edgeR/versions/3.14.0/topics/plotBCV
# https://www.researchgate.net/figure/Scatterplot-of-the-biological-coefficient-of-variation-BCV-against-the-average_fig3_304186082 
```


```{r Create linear model1, eval=FALSE}
# Fit general linear model to y based on design.
fit <- glmFit(y, design)
# Get likelihood-ratio test.
lrt <- glmLRT(fit, coef = "EXP_F1")
# Extracts the top DE tags in a data frame for a given pair of groups, ranked by p-value or absolute log-fold change.
# https://www.rdocumentation.org/packages/edgeR/versions/3.14.0/topics/topTags
# Formating toptag data to fit into table.
df1 <- data.frame(topTags(lrt))
df1$logFC <- round(df1$logFC, 3)
df1$logCPM <- round(df1$logCPM, 3)
df1$LR <- round(df1$LR, 3)
df1$PValue <- formatC(df1$PValue , format = "e", digits = 3)
df1$FDR <- formatC(df1$FDR , format = "e", digits = 3)
```


```{r Determine significant DEGs1, eval=FALSE}
# Order lrt based on p-values.
o <- order(lrt$table$PValue)
# Computes counts per million (CPM) or reads per kilobase per million (RPKM) values.
# https://www.rdocumentation.org/packages/edgeR/versions/3.14.0/topics/cpm
# Top 10.

knitr::kable(head(round(cpm(y)[o[1:10], 1:10], 3)), caption = "Table 3: Example of Count per Million Data") %>% add_footnote( label = "*The top 10 expression levels counts per million example.*")
# Classify a series of related t-statistics as up, down or not significant. A number of different multiple testing schemes are offered which adjust
# for multiple testing down the genes as well as across contrasts for each gene. 
# https://www.rdocumentation.org/packages/limma/versions/3.28.14/topics/decideTests

knitr::kable(df1, caption = "Table 4: Statitical Summary of the top 10 tags", digits = 5) %>% add_footnote( label = "*Statitical summary of top ten tags. logFC = logarithmic Fold Change, logCPM = log2 of copies per million, LR = likelihood ratio, PValue = p-value, FDR = adjusted p-value.*")

# Summarize results
df1 <- summary(decideTests(lrt, adjust.method = "fdr", p.value = 0.05))
df1 <- as.data.frame(df1)
colnames(df1) <- c("Tags", "N", "Count")
df1 <-
  df1 %>%
  dplyr::select(., -N)

knitr::kable(df1, caption = "Table 5: Tags Counts")%>% kable_styling(full_width = FALSE) %>% add_footnote( label = "*A count of expression levels for tags relative to the no previous COVID-19 infection group to the previous COVID-19 group. The counts are of the expression that have relatively increase (Up), expression levels that have relatively decrease (Down), and have not changed (NotSig). The test for significants was done on the FDR values with a alpha value of 0.05*")
```

```{r plotMD1, eval=FALSE}
# Make MD plot of ltr.
plotMD(lrt, main = "Figure 10: Mean Difference Plot of Expression Data") +
  title(sub = str_wrap("*The x-axis is the log fold change and the y-axis is the average log CPM.*"), adj = 0.5, line = 6) 
# Add lines.
abline(h=c(-1, 1), col="blue")
```

```{r Top 10 Degs compare1, eval=FALSE}
# Create reference between ENST and Genes
ref_geo_genes <- extra_data[,1:2]
colnames(ref_geo_genes) <- c("ENST", "Genes")
# Create a reference of geo accession to COVID_EXP
ref_geo_exp <- data.frame(GSM = y$samples$geo_accession,
                          CE = y$samples$COVID_EXP)
# Get top 10 DEGs names
DEGs_10 <- rownames(topTags(lrt, n = 10))
# Get CPM for top 10 DEGs as data.frame
y_10_cpm <- as.data.frame(cpm(y$counts)[DEGs_10,])
# Turn gene ideas into own column 
y_10_cpm <- tibble::rownames_to_column(y_10_cpm, "ENST")
# Create CPM table with sample names
y_10_cpm %>% # Call data.
  pivot_longer(., # pivot table
               cols = starts_with("GSM"), # Pivot by GSM columns.
               names_to = "GSM", # Name new column to GSM
               values_to = "CPM") %>% # Assign values to CPM column
  left_join(., ref_geo_exp, by = "GSM") %>% # Match samples with type of affect.
  left_join(., ref_geo_genes, by = "ENST") %>% # Match ENST with genes.
  mutate(., Genes_CE = paste(Genes, "-", CE)) %>% # Add column of both affect and gene
  ggplot(., # Start ggplot
         aes(x = Genes_CE, y = CPM, fill = CE)) + # Assign variables 
  geom_boxplot() + # Create box plot.
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0         
    )) + 
  labs(title = sprintf("Figure 11: Log2(expr + 1) — After SVA Correction"), # Title
       x = "Sample", y = "log2(expr + 1)",
       caption = str_wrap("Top 10 differentially expressed genes. The log2 of each expression grouped together by groups in boxplot. 1 was added to each expression value to avoid error."))
```

```{r Assign DEGs1, eval=FALSE}
# edgeR results for p-value of 0.05
eres0.05 <- decideTests(lrt, p.value = 0.05, adjust.method = "fdr")
```

```{r Create excel of DEGs1, eval=FALSE}
# Create edgeR-full sheet.
lrt_sheet <- as.data.frame(topTags(lrt, n = Inf)) # Get statistical data
lrt_sheet <- rownames_to_column(lrt_sheet, var = "ensembl_transcript_id") # Assign ensembl_transcript_id as rownames' colname
lrt_sheet <- left_join(lrt_sheet, extra_data, by = "ensembl_transcript_id") # Join to description data
lrt_sheet <- lrt_sheet %>%
  dplyr::rename(symbol = external_gene_name) %>%
  dplyr::rename(genes = ensembl_transcript_id)
# Create DEGs.xlsx
sheets <- list("degs_sheet" = lrt_sheet)
write_xlsx(sheets, "Final_BIOS658_Stillman/Final_DEGs.xlsx")
# https://stackoverflow.com/questions/27713310/easy-way-to-export-multiple-data-frame-to-multiple-excel-worksheets
```

```{r Set stats1, eval=FALSE}
# Set stats
p_val_cutoff   <- 0.05 # Regular p-value cutoff
p_adj_cutoff   <- 0.3 # FDR cutoff
nplot          <- 50 # How many genes to plot on a heatmap
nbox           <- 9  # How many genes to plot on a boxplot
ntable         <- 15 # Number of genes to output in a DEG table
nkegg          <- 35 # Number of genes to output in a KEGG table
col3 <- RColorBrewer::brewer.pal(20, "RdBu") # Create color palette
```

```{r Set up annotation1, eval=FALSE}
gene_annotations <- # Assign
lrt_sheet %>% # Load bioinfo data.
  dplyr::select(., ensembl_gene_id,  genes, symbol , gene_biotype, description) %>% # Select columns of interest
  dplyr::rename(ensgene = ensembl_gene_id,  enstgene = genes, symbol = symbol, biotype = gene_biotype) %>% # Rename columns to be more clear
  tidyr::drop_na() # Remove NAs
  
# Create sample annotation
sample_annotation <- data.frame(
  Sample = y$samples$title,
  Group = y$samples$COVID_EXP,
  Geo = y$samples$geo_accession
)
```

```{r Set up LRT sheet1, eval=FALSE}
# Isolate protein coding biotype
res <- lrt_sheet[lrt_sheet$gene_biotype == "protein_coding" & !is.na(lrt_sheet$gene_biotype), ]
# Select genes (ENSG) that meet res filters
selected_genes = unique(res$genes[!is.na(res$genes)])
# Get top 9 genes
genes_slice <- selected_genes[1:min(length(selected_genes), nbox)]
# Select genes and match order (using ensgene)
genes.to.plot <- res[res$genes %in% genes_slice, ]
# Get counts of genes of interest
matrix.to.plot <- counts[counts$enstgene %in% genes_slice, ]
# Reshape for ggplot
colnames(matrix.to.plot) <- c("Gene", y$samples$COVID_EXP)
matrix.to.plot_melted <- tidyr::pivot_longer(matrix.to.plot, cols = colnames(matrix.to.plot)[colnames(matrix.to.plot) != "Gene"]) # Pivot data for easier handling
matrix.to.plot_melted$Gene <- as.factor(matrix.to.plot_melted$Gene) # Turn gene into factors
# Plot
ggplot(matrix.to.plot_melted, aes(x = name, y = value, group = name)) + # X as names and y as value, group by name
  geom_boxplot(aes(fill = name)) + # Boxplot and fill by name
  facet_wrap(~ Gene, ncol = 3, scales = "free_y") + # Facet by gene
  labs(title = sprintf("Figure 12: Expression of Protein Coding mRNA"), # Title
       x = "Transcription IDs", y = "Counts",
       caption = str_wrap("The top 9 differentialy expressed transcripts are present in this box-plot The y-axis are the counts and the x-axis are the ensembl transcription IDs."), adj = 0)
```

```{r Heatmap31, eval=FALSE}
# Prepare genes to plot (top nplot)
genes.to.plot <- res[2:50, c("genes"), drop = FALSE] # Select genes to plot
# Create matrix of counts of genes of interest
matrix.to.plot <- counts[counts$enstgene %in% genes.to.plot$genes, ]
# Set row names to ENST
rownames(matrix.to.plot) <- matrix.to.plot$enstgene
# Remove ENST column
matrix.to.plot <- matrix.to.plot[ , 2:ncol(matrix.to.plot)]
# Create a dataframe that links symbols to ENST
ENST_TO_SYMBOL <- 
  lrt_sheet %>%
  dplyr::select(., genes, symbol)
# Translate ENST to symbols
ENST_df <- data.frame(genes = rownames(matrix.to.plot))
ENST_df <- left_join(ENST_df, ENST_TO_SYMBOL, by = "genes")
# Give matrix counts symbols as row names
matrix.to.plot <- matrix.to.plot[!duplicated(ENST_df$symbol),]
ENST_df <- ENST_df[!duplicated(ENST_df$symbol),]
rownames(matrix.to.plot) <- ENST_df$symbol
# Make group names rownames
annotation_col <- data.frame(Group = y$samples$COVID_EXP)
rownames(annotation_col) <- y$samples$title
# Plot heatmap
two <- pheatmap(matrix.to.plot, 
         color = colorRampPalette(c("navy", "white", "firebrick3"))(100), # Assumed col3 equivalent
         clustering_method = "ward", # Cluster method
         treeheight_row = FALSE, # No cluster tree
         treeheight_col = FALSE, # No cluster tree
         annotation_col = annotation_col, # Set annotation
         labels_row = genes.to.plot$symbol, # Lables for row set to gene symbols
         scale = "row",
         main = "Figure 13: Expression of Top 48 Genes for Each Sample",
         fontsize_row = 5, fontsize_col = 5) # Set scale to row
```

```{r Heatmap41, eval=FALSE}
my_caption <- textGrob(str_wrap("Heat map of relative gene expression between the various samples. The  Ward's method was used to calculate clustering."),
                       gp = gpar(fontsize = 9, fontface = "italic"),
                       just = "left", x = 0.05)
grid.arrange(
    grobs = list(two[[4]], my_caption), # two[[4]] is the main heatmap grob
    heights = c(1, 0.1), # Adjust as needed (e.g., 1 for plot, 0.1 for caption)
    ncol = 1
)
# google(pheatmap r caption)
```


```{r Expression volcano plot1, eval=FALSE}
# use the function -- add_regulate to add a regulate column 
# to the DEG result data. 
res$FDR <- as.numeric(res$FDR)
data <- add_regulate(data = res, log2FC_name = "logFC",
                     fdr_name = "FDR", log2FC = 1, fdr = 0.3)
data <- na.omit(data)


gradual_volcano(data, x = "log2FoldChange", y = "padj", # Data and axises
          label = "symbol", label_number = 10, # Name top ten genes
          fills = c("#53a4cf", "#aec5d1", "white", "#e2ae96", "#cc917c", "#a96d5d", "#91403e"), # Set scale of colors
          colors = "#404950", # Outline color for points
          log2FC_cut = 0, # Log2FC cut off
          FDR_cut = 1, # FDR cut off
          add_line = FALSE, # No add line
          pointSizeRange = c(2, 2)) + # Size of points
  ggtitle("Figure 14: Volcano Plot of Transcript Expression Data") +
  theme(plot.title = element_text(hjust = 0.5), plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0         
    )) +
  labs(caption = str_wrap("Volcano plot of transcript expression levels. The top ten differentially expressed transcripts are labeled."))

```

```{r gene volcano plot1, eval=FALSE}
# Select symbol, logfc, and pvalue from lrt_sheet
lrt_sheet_g <- lrt_sheet[, c("symbol", "logFC", "PValue")]
# Calculate mean logFC for symbols
lrt_sheet_g1 <-
  lrt_sheet_g %>%
  group_by(., symbol) %>%
  summarize(., Log2FC = mean(logFC))

# Find symbols that only occur once and put into their own dataframe
single_list <- c()
for (symbol in unique(lrt_sheet_g$symbol)) {
  s_count = length(which(lrt_sheet_g$symbol==symbol))
  if (s_count == 1) {
    single_list <- c(single_list, symbol)
  }
 else{} 
}
lrt_sheet_g0 <- lrt_sheet[, c("symbol", "PValue")]
lrt_sheet_g2 <- lrt_sheet_g0[lrt_sheet_g0$symbol %in% single_list, ]

# Find symbols that occur more than once and put into their own dataframe
double_list <- c()
for (symbol in unique(lrt_sheet_g$symbol)) {
  s_count = length(which(lrt_sheet_g$symbol==symbol))
  if (s_count > 1) {
    double_list <- c(double_list, symbol)
  }
 else{} 
}
lrt_sheet_g3 <- lrt_sheet_g0[lrt_sheet_g0$symbol %in% double_list, ]
# Calculate combined p-values
lrt_sheet_g3 <-
  lrt_sheet_g3 %>%
  group_by(., symbol) %>%
  summarize(., PValue = sumlog(PValue)$p)
# Combine all the p-values together.
lrt_sheet_g23 <- rbind(lrt_sheet_g2, lrt_sheet_g3)
# Join mean Log2FC and mean P-values
lrt_sheet_g4 <- left_join(lrt_sheet_g1, lrt_sheet_g23, by = "symbol")
# remove ""
lrt_sheet_g4 <- lrt_sheet_g4 %>%
  dplyr::filter(., symbol != "")
# Aadd FDR column
lrt_sheet_g4$FDR <- p.adjust(lrt_sheet_g4$PValue, method = "fdr")

# use the function -- add_regulate to add a regulate column 
# to the DEG result data. 
lrt_sheet_g4$FDR <- as.numeric(lrt_sheet_g4$FDR)
data1 <- add_regulate(data = lrt_sheet_g4, log2FC_name = "logFC",
                     fdr_name = "FDR", log2FC = 1, fdr = 0.3)
data1 <- na.omit(data)


gradual_volcano(data1, x = "log2FoldChange", y = "padj", # Data and axises
          label = "symbol", label_number = 10, # Name top ten genes
          fills = c("#53a4cf", "#aec5d1", "white", "#e2ae96", "#cc917c", "#a96d5d", "#91403e"), # Set scale of colors
          colors = "#404950", # Outline color for points
          log2FC_cut = 0, # Log2FC cut off
          FDR_cut = 1, # FDR cut off
          add_line = FALSE, # No add line
          pointSizeRange = c(2, 2)) + # Size of points
          ggtitle("Figure 15: Volcano Plot of Gene Expression Data") +
          theme(plot.title = element_text(hjust = 0.5), plot.caption = element_text(
            size = 10,      
            color = "black", 
            face = "italic",    
            hjust = 0         
          )) +
          labs(caption = str_wrap("Volcano plot of gene expression levels. The top ten differentially expressed genes are labeled."))
```

```{r Compare source and analysis1, eval=FALSE}
url <- "https://static-content.springer.com/esm/art%3A10.1038%2Fs43587-022-00321-w/MediaObjects/43587_2022_321_MOESM3_ESM.xlsx"
# Destination file name
destfile <- "43587_2022_321_MOESM3_ESM.xlsx"
# Download the file
download.file(url, destfile, mode = "wb")
# Get data from research
research_data <- read_excel("43587_2022_321_MOESM3_ESM.xlsx", sheet = "S2a. COVID vs Control")
# Isolate adj.p-value below 0.05
research_data <- research_data[research_data$padj < 0.05, ]
# Isolate adj.p-value below 0.05
lrt_sheet_p0.05 <- lrt_sheet[lrt_sheet$FDR < 0.05,]
# Remove duplicates symbols
lrt_sheet_p0.05 <-
  lrt_sheet_p0.05 %>% 
  distinct(., symbol, .keep_all = TRUE)
research_data <- 
  research_data %>%
  distinct(., external_gene_name, .keep_all = TRUE)
# Length of data points
r_total <- length(research_data$external_gene_name)
m_total <- length(lrt_sheet_p0.05$symbol)
# Sum of matching
total_match <- sum(research_data$external_gene_name %in% lrt_sheet_p0.05$symbol)
# Sum of not matching
total_not_match <- sum(!(research_data$external_gene_name %in% lrt_sheet_p0.05$symbol))
# Length of data points
r_utotal <- length(research_data[research_data$log2FoldChange > 0,]$external_gene_name)
m_utotal <- length(lrt_sheet_p0.05[lrt_sheet_p0.05$logFC > 0,]$symbol)
# Sum of matching up degs
total_match_up <- sum(research_data[research_data$log2FoldChange > 0,]$external_gene_name %in% lrt_sheet_p0.05[lrt_sheet_p0.05$logFC > 0,]$symbol)
# Sum of not matching up degs
total_not_match_up <- sum(!(research_data[research_data$log2FoldChange > 0,]$external_gene_name %in% lrt_sheet_p0.05[lrt_sheet_p0.05$logFC > 0,]$symbol))
# Length of data points
r_dtotal <- length(research_data[research_data$log2FoldChange <= 0,]$external_gene_name)
m_dtotal <- length(lrt_sheet_p0.05[lrt_sheet_p0.05$logFC <= 0,]$symbol)
# Sum of matching down degs
total_match_down <- sum(research_data[research_data$log2FoldChange <= 0,]$external_gene_name %in% lrt_sheet_p0.05[lrt_sheet_p0.05$logFC <= 0,]$symbol)
# Sum of not matching down degs
total_not_match_down <- sum(!(research_data[research_data$log2FoldChange <= 0,]$external_gene_name %in% lrt_sheet_p0.05[lrt_sheet_p0.05$logFC <= 0,]$symbol))

compare_tags <- data.frame(Metric = c("Mavrikaki project's total tags", "Stillman project's total tags", "Matches of tags between projects",
                      "No matches of tags between projects", "Mavrikaki project's total Up tags", "Stillman project's total Up tags",
                      "Matches of up tags between projects", "No matches of up tags between projects", "Mavrikaki project's total down tags",
                      "Stillman project's total down tags", "Matches of down tags between projects", "No matches of down tags between projects"),
           Counts = c(r_total, m_total, total_match, total_not_match, r_utotal, m_utotal, total_match_up, total_not_match_up, r_dtotal,
                      m_dtotal, total_match_down, total_not_match_down))

knitr::kable(compare_tags, caption = "Table 6: Counts and Comparison between Source Study and Current Analysis")  %>% kable_styling(full_width = FALSE) %>% add_footnote( label = "*The data for this analysis was sourced from a different study with the first auther is Dr. Maria Mavrikaki. This chart compares that study's tag results with analysis tag results.*")
```



```{r stop1, eval=FALSE}
#Stop_now
```

```{r remove everything1, eval=FALSE}
rm(list = ls())
```

```{r setup11, eval=FALSE}
# Set up the environment
library(knitr)
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=F, tidy=T, fig.keep='high', echo=F, dpi=100, warnings=F, message=F, comment=NA, warning=F, results='as.is', fig.width = 10, fig.height = 6) #out.width=700, 
library(pander)
panderOptions('table.split.table', Inf)
set.seed(1)
library(dplyr)
options(stringsAsFactors = FALSE)
```

```{r libraries1, eval=FALSE}
library(readxl)
library(writexl)
library(enrichR) # install.packages("enrichR")
library(annotables) # devtools::install_github("stephenturner/annotables") Annotations of Ensembl IDs
library(clusterProfiler)
library(DOSE)
library(ggplot2)
library(HGNChelper) # for correcting gene names 
library(tidyverse)
library(msigdbr)
library(nichenetr)
library(enrichplot)
library(org.Mm.eg.db)
library(msigdb)
```

```{r settings1, eval=FALSE}
# Data
data_dir <- "Final_BIOS658_Stillman" # Working directory
# File to save all results of differential expression analysis
fileNameIn1   <- file.path(data_dir, "Final_DEGs.xlsx") 
degs_sheet <- "Control vs. Covid19"
# degs_sheet <- "2.p53mut_5Gy_vs_p53mut_noGy"
# degs_sheet <- "3.M54_L_vs_Ctrl_L"
# degs_sheet <- "4.M55_L_vs_Ctrl_L"
# degs_sheet <- "5.C231_HP_vs_C231_HD"
# degs_sheet <- "6.C231_LP_vs_C231_LD"


up_dn_separate <- FALSE # Whether to run KEGG separately on up- and downregulated genes. FALSE - do not distinguish directionality
p_val_cutoff   <- 0.05 # Regular p-value cutoff
FDR_cutoff     <- 0.3# FDR cutoff for DEGs
msigdb_all     <- FALSE # Use all MSigDb categories (TRUE), or c("C2", "C5", "H") (FALSE)
fileNameOut1 <- file.path(data_dir, paste0("results/GSEA2_", make.names(degs_sheet), ".xlsx"))
# Create output folder, if not exists
if (!dir.exists(file.path(data_dir, "results"))) dir.create(file.path(data_dir, "results"))

# Which pathway enrichment analysis to run
run_gsea <- TRUE # If TRUE, GSEA pathway enrichment analysis is run, otherwise, standard hypergeometric-based enrichment
min_kegg_genes <- 20 # Minimum number of genes to run enrichment analysis on
max_kegg_genes <- 2000 # Maximum number of genes to run enrichment analysis on
p_adj_cutoff   <- 1 # FDR cutoff for enrichment results
nperm          <- 1000 # Number of permutations (for GSEA)
num_gseaplots  <- 3 # Number of GSEA plots to plot
ntop_symbols   <- 24 # Number of top gene entries to annotate with symbols in entrez_to_symbols function (set to Inf to annotate all)
```

```{r1, eval=FALSE}
# Mutually exclusive selectors, which analysis should be run. Only one may be TRUE
human_analysis <- TRUE
mouse_analysis <- FALSE

# Bioconductor setup (if needed):
# if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# BiocManager::install(c("AnnotationHub", "ensembldb", "org.Hs.eg.db", "org.Mm.eg.db"))

suppressPackageStartupMessages({
  library(AnnotationHub)
  library(ensembldb)
  library(AnnotationDbi)
  library(dplyr)
  library(tibble)
})

# Helper to get the latest EnsDb for a species/build from AnnotationHub
get_latest_EnsDb <- function(species, genome) {
  ah <- AnnotationHub::AnnotationHub()
  q <- AnnotationHub::query(ah, c("EnsDb", species, genome))
  if (length(q) == 0L) stop("No EnsDb found for: ", species, " ", genome)
  q[[which.max(as.Date(mcols(q)$rdatadateadded))]]
}

# Helper to build gene annotations and lengths
build_gene_data <- function(ensdb, orgdb, canonical_chrs, species_code, kegg_set, msigdbr_org) {
  # Pull genes with required columns from EnsDb
  g <- genes(
    ensdb,
    columns = c("gene_id", "gene_name", "gene_biotype", "seq_name",
                "gene_seq_start", "gene_seq_end")
  )
  df <- as_tibble(g) %>%
    transmute(
      ensgene = gene_id,
      symbol = gene_name,
      biotype = gene_biotype,
      chr = as.character(seqnames),
      start = as.integer(start),
      end = as.integer(end)
    ) %>%
    dplyr::filter(chr %in% canonical_chrs)

  # Map description (GENENAME) and ENTREZID from org.*.eg.db using ENSEMBL keys
  desc_map <- AnnotationDbi::select(
    orgdb,
    keys = unique(df$ensgene),
    keytype = "ENSEMBL",
    columns = c("GENENAME", "ENTREZID")
  ) %>%
    dplyr::rename(ensgene = ENSEMBL, description = GENENAME, entrezid = ENTREZID)

  df <- df %>%
    left_join(desc_map, by = "ensgene")

  # Final gene_annotations: protein_coding, non-NA symbol/description
  gene_annotations <- df %>%
    # dplyr::filter(
      # biotype == "protein_coding",
      # !is.na(symbol),
      # !is.na(description),
      # description != ""
    # ) %>%
    distinct(ensgene, symbol, biotype, description, entrezid, .keep_all = FALSE)

  # Gene length as gene span (end - start)
  gene_length <- df %>%
    transmute(Geneid = ensgene, Length = end - start) %>%
    distinct()

  # Background symbols
  all.symbol <- unique(gene_annotations$symbol)

  list(
    gene_annotations = gene_annotations,
    gene_length = gene_length,
    all.symbol = all.symbol,
    OrgDb = orgdb,
    species = species_code,
    KEGG = kegg_set,
    msigdbr_org = msigdbr_org
  )
}

# Flags controlling which species to process
# Set these as needed:
# human_analysis <- TRUE
# mouse_analysis <- FALSE

if (exists("human_analysis") && isTRUE(human_analysis)) {
  suppressPackageStartupMessages(library(org.Hs.eg.db))

  # EnsDb for human GRCh38 (change to "GRCh37" if you need that build)
  edb_hs <- get_latest_EnsDb("Homo sapiens", "GRCh38")

  human <- build_gene_data(
    ensdb = edb_hs,
    orgdb = org.Hs.eg.db,
    canonical_chrs = c(as.character(1:22), "X", "Y", "MT"),
    species_code = "hsa",
    kegg_set = "KEGG_2019_Human",
    msigdbr_org = "Homo sapiens"
  )

  gene_annotations <- human$gene_annotations
  gene_length <- human$gene_length
  all.symbol <- human$all.symbol
  OrgDb <- "org.Hs.eg.db"
  species <- "hsa"
  KEGG <- human$KEGG
  msigdbr_org <- human$msigdbr_org
}

if (exists("mouse_analysis") && isTRUE(mouse_analysis)) {
  suppressPackageStartupMessages(library(org.Mm.eg.db))

  # EnsDb for mouse GRCm38 (switch to "GRCm39" for the latest)
  edb_mm <- get_latest_EnsDb("Mus musculus", "GRCm38")

  mouse <- build_gene_data(
    ensdb = edb_mm,
    orgdb = org.Mm.eg.db,
    canonical_chrs = c(as.character(1:19), "X", "Y", "MT"),
    species_code = "mmu",
    kegg_set = "KEGG_2019_Mouse",
    msigdbr_org = "Mus musculus"
  )

  gene_annotations <- mouse$gene_annotations
  gene_length <- mouse$gene_length
  all.symbol <- mouse$all.symbol
  OrgDb <- "org.Mm.eg.db"
  species <- "mmu"
  KEGG <- mouse$KEGG
  msigdbr_org <- mouse$msigdbr_org
}

# Result objects:
# - gene_annotations: tibble with columns ensgene, symbol, biotype, description, entrezid
# - gene_length: data.frame/tibble with columns Geneid, Length
# - all.symbol: unique symbols vector
```


```{r 1, eval=FALSE}
# Mutually exclusive selectors, which analysis should be run. Only one may be TRUE
human_analysis <- TRUE
mouse_analysis <- FALSE

# Prepate gene annotations, remove non-canonical chromosome names
if (human_analysis) {
  library(org.Hs.eg.db)
  OrgDb = "org.Hs.eg.db"; species = "hsa"
  gene_annotations <- grch38[ !(grepl("_", grch38$chr) | grepl("GL", grch38$chr)), c("ensgene", "symbol", "biotype", "description")]
  gene_annotations <- gene_annotations[ !duplicated(gene_annotations) & !is.na(gene_annotations$symbol) & gene_annotations$description != "" & gene_annotations$biotype == "protein_coding", ]
  KEGG <- "KEGG_2019_Human"
  msigdbr_org <- "Homo sapiens"
  # Gene length for TPM calculations
  gene_length <- data.frame(Geneid = grch38$ensgene, Length = grch38$end - grch38$start)
}
if (mouse_analysis) {
  library(org.Mm.eg.db)
  OrgDb = "org.Mm.eg.db"; species = "mmu"
  gene_annotations <- grcm38[ !(grepl("_", grcm38$chr) | grepl("GL", grcm38$chr)), c("ensgene", "symbol", "biotype", "description")]
  gene_annotations <- gene_annotations[ !duplicated(gene_annotations) & !is.na(gene_annotations$symbol) & gene_annotations$description != "" & gene_annotations$biotype == "protein_coding", ]
  KEGG <- "KEGG_2019_Mouse"
  msigdbr_org <- "Mus musculus"
  # Gene length for TPM calculations
  gene_length <- data.frame(Geneid = grcm38$ensgene, Length = grcm38$end - grcm38$start)
}
# All genes for background
all.symbol <- unique(gene_annotations$symbol) 
```

```{r eval=FALSE}
mtx <- read_xlsx(fileNameIn1, sheet = "degs_sheet")
res <- data.frame(symbol = mtx$symbol, logFC = mtx$logFC, p.val = mtx$PValue, p.adj = mtx$FDR)
res <- res[ order(res$p.val, decreasing = FALSE), ]
# fix gene names 
# current_map <- getCurrentHumanMap()
# genes_checked <- checkGeneSymbols(res$symbol, map = current_map)
# res$symbol <- genes_checked$Suggested.Symbol
# Convert gene names for other organisms
# if (!human_analysis & mouse_analysis) {
#   res$symbol <- nichenetr::convert_mouse_to_human_symbols(res$symbol)
#   res <- res[!is.na(res$symbol), ]
#   res <- res[order(res$p.val, decreasing = FALSE), ]
# }
```

```{r hyper_kegg1, eval=FALSE}
kegg_enrich <- function(compartment_genes, p_adj_cutoff = p_adj_cutoff) {
  # stop if min_kegg is not met 
  stopifnot(length(compartment_genes) >= min_kegg_genes)
  res.kegg <- enrichr(unique(compartment_genes), databases = KEGG) # KEGG results only
  # If significant results are present, save them
  if (nrow(res.kegg[[KEGG]]) > 0 & sum(res.kegg[[KEGG]]$Adjusted.P.value < p_adj_cutoff) > 0) {
    res.kegg <- as.data.frame(res.kegg[[KEGG]])
    res.kegg <- res.kegg[res.kegg$Adjusted.P.value < p_adj_cutoff, , drop = FALSE]
    compartment_genes <- res.kegg
    # reorder the genes alphabetically 
    compartment_genes <- compartment_genes %>% 
      # separate the rows by splitting by the delimiter and expanding the rows 
      separate_rows(Genes, convert = TRUE, sep = ";") %>% 
      # group the genes by their Term & other columns to keep them 
      group_by(Term, Overlap, P.value, Adjusted.P.value, Old.P.value, Old.Adjusted.P.value,
               Odds.Ratio, Combined.Score) %>% 
      # sort the genes for each term 
      arrange(Genes) %>% 
      summarise(Genes = paste(Genes, collapse="/")) %>% 
      arrange(P.value, Adjusted.P.value)
  } else {
    compartment_genes <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 9))
    colnames(compartment_genes) <- c("Term", "Overlap", "P.value", "Adjusted.P.value", "Old.P.value", "Old.Adjusted.P.value", "Odds.Ratio", "Combined.Score", "Genes")
    compartment_genes$`P.value` = 0
    compartment_genes$`Adjusted.P.value` = 0
    compartment_genes$`Old.P.value` = 0
    compartment_genes$`Old.Adjusted.P.value` = 0
    compartment_genes$`Odds.Ratio` = 0
    compartment_genes$`Combined.Score` = 0
  }
  return(compartment_genes)
}

# run unranked KEGG analysis 
websiteLive <- TRUE # Check if EnrichR is up
  dbs <- listEnrichrDbs()
  if (is.null(dbs)) websiteLive <- FALSE
  if(websiteLive) {
    # Subset the number of DEGs for KEGG analysis to the maximum
    if (nrow(res[res$p.val < p_val_cutoff, ]) > max_kegg_genes) {
      degs_subset <- res[1:max_kegg_genes, ]
    } else {
      degs_subset <- res[res$p.adj < FDR_cutoff, ]
    }
    # Get list of up- and downregulated genes
    up.genes <- sort(unique(degs_subset$symbol[ degs_subset$logFC > 0 ]))
    dn.genes <- sort(unique(degs_subset$symbol[ degs_subset$logFC < 0 ]))
    res.kegg  <- NULL # Initially, empty value
    # if process up and down regulated genes separately 
    if (up_dn_separate) {
      # run unranked KEGG on up and down regulated genes separately 
      print(paste0("KEGG pathway run on ", length(up.genes), " upregulated and ",
                   length(dn.genes), " downregulated genes."))
      res.kegg.up <- kegg_enrich(up.genes, p_adj_cutoff = p_adj_cutoff) %>%
        dplyr::mutate(Direction = "UP") # add new Direction column 
      res.kegg.dn <- kegg_enrich(dn.genes, p_adj_cutoff = p_adj_cutoff) %>%
        dplyr::mutate(Direction = "DN") # add new Direction column 
      res.kegg = rbind(res.kegg.up, res.kegg.dn)
      res.kegg <- res.kegg[order(res.kegg$P.value), ]
    } else {
      # run the up regulated and down regulated genes together 
      print(paste0("KEGG pathway run on ", length(unique(c(up.genes, dn.genes))),
                   " genes without distinguishing them by directionality."))
      # run hypergeomtric KEGG analysis on combination of genes 
      res.kegg <- kegg_enrich(unique(c(up.genes, dn.genes)), 
                              p_adj_cutoff = p_adj_cutoff)
    }
  }
```

```{r hyper_msig1, eval=FALSE}
# Convert Entrez IDs to symbols using gene_annotations object
# This function uses the gene_annotations tibble that contains entrezid-to-symbol mappings
#
# @param entrez_list Character vector of slash-separated EntrezID strings
# @param gene_annotations Tibble with columns entrezid and symbol for mapping
# @param ntop Number of entries to process (default: 24)
# @return Character vector with EntrezIDs converted to gene symbols
entrez_to_symbols <- function(entrez_list, gene_annotations, ntop = 24) {
  # Create a fast lookup table (named vector) from entrezid to symbol
  # Filter out NA entrezids, keep first occurrence per entrezid for O(1) hash-based lookups
  entrez_map_df <- gene_annotations %>%
    dplyr::filter(!is.na(entrezid)) %>%
    dplyr::distinct(entrezid, symbol)
  entrez_lookup <- setNames(entrez_map_df$symbol, entrez_map_df$entrezid)
  
  # Function to convert a single slash-separated string
  convert_single <- function(entrez_string) {
    entrez_ids <- unlist(strsplit(entrez_string, "/"))
    # Use named vector indexing for O(1) lookup with proper NA handling
    matched_symbols <- entrez_lookup[entrez_ids]
    symbols <- ifelse(is.na(matched_symbols), entrez_ids, matched_symbols)
    # Sort alphabetically for consistent output across runs
    paste(sort(symbols), collapse = "/")
  }
  
  # Initialize result as original input
  result <- entrez_list
  
  # Process top ntop entries (if ntop is Inf, process all entries)
  n_to_process <- if (is.infinite(ntop)) length(entrez_list) else min(ntop, length(entrez_list))
  result[1:n_to_process] <- vapply(entrez_list[1:n_to_process], convert_single, character(1))
  
  return(result)
}


# Get unique categories
if (msigdb_all) {
  m_df <- msigdbr(species = msigdbr_org)
  m_df_gs_cat <- unique(m_df$gs_collection) %>% sort()
} else {
  # Use most informative ones
  m_df_gs_cat <- c("C2", "C5", "H")
}

# Function to perform enrichment analysis using MSigDb signatures
msigdb_enrich <- function(dataset, p_adj_cutoff = p_adj_cutoff) {
  # Top DEGs for enrichr
  # res.all <- dataset[dataset$p.val < p_val_cutoff, ]
      # Subset the number of DEGs for KEGG analysis to the maximum
    if (nrow(dataset[dataset$p.val < p_val_cutoff, ]) > max_kegg_genes) {
      res.all <- dataset[1:max_kegg_genes, ]
    } else {
      res.all <- dataset[dataset$p.adj < p_val_cutoff, ]
    }
  # Convert symbols to entrezids
  eid <- bitr(res.all$symbol, fromType="SYMBOL", toType="ENTREZID", OrgDb=OrgDb)
  # Attach converted entrezids
  res.all <- left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[ !is.na(res.all$ENTREZID), ]
  # List of t-statistics
  geneList_significant <- res.all$logFC
  # Make it named
  names(geneList_significant) <- res.all$ENTREZID
  # And decreasing sorted
  geneList_significant <- sort(geneList_significant, decreasing = TRUE)
  res.msigdf.all <- list()
  # gs_cat="C2" # For testing
  for (gs_cat in m_df_gs_cat) {
    # Term to gene
     m_t2g <- msigdbr(species = msigdbr_org, collection = gs_cat) %>% 
       dplyr::distinct(gs_name, ncbi_gene)
    # Term to description 
    m_t2d <- msigdbr(species = msigdbr_org, collection = gs_cat) %>% 
       dplyr::distinct(gs_name, gs_description)
    # Enrichment analysis
    if (up_dn_separate) {
      # run unranked MSigDb on up and down regulated genes separately 
      print(paste0("MSigDb run on ", length(geneList_significant[geneList_significant > 0]), " upregulated and ",
                   length(geneList_significant[geneList_significant < 0]), " downregulated genes."))
      # Upregulated genes
      em.up <- enricher(names(geneList_significant[geneList_significant > 0]), TERM2GENE=m_t2g, pvalueCutoff = p_adj_cutoff)
      if (!is.null(em.up)) {
        if (!any(is.na(em.up@result$qvalue))) {
          em.up@result <- em.up@result %>% dplyr::mutate(Direction = "UP") # add new Direction column 
        } else {
          em.up <- NULL
        }
      }
      # Downregulated genes
      em.dn <- enricher(names(geneList_significant[geneList_significant < 0]), TERM2GENE=m_t2g, pvalueCutoff = p_adj_cutoff)
      if (!is.null(em.dn)) {
        if (!any(is.na(em.dn@result$qvalue))) {
          em.dn@result <- em.dn@result %>% dplyr::mutate(Direction = "DN") # add new Direction column 
        } else {
          em.dn <- NULL
        }
      }
      #  # Check if the results are non-empty
      if (!(is.null(em.up) | is.null(em.dn))) {
        res.msigdf.em <- rbind(em.up@result, em.dn@result)
        res.msigdf.em <- res.msigdf.em[res.msigdf.em$p.adjust < p_adj_cutoff, , drop = FALSE]
        res.msigdf.em$core_enrichment <- entrez_to_symbols(res.msigdf.em$geneID, gene_annotations, ntop = ntop_symbols)
        # sort the genes alphabetically
        res.msigdf.em <- res.msigdf.em %>% 
          # separate the rows by splitting by the delimiter and expanding the rows 
          separate_rows(geneID, convert = TRUE, sep = "/") %>% 
          # group the genes by their other columns to keep them 
          group_by(ID, Description, GeneRatio, BgRatio, pvalue, p.adjust, qvalue, Count, core_enrichment, Direction, core_enrichment) %>%
          # sort the genes for each term 
          arrange(geneID) %>% 
          summarise(geneID = paste(geneID, collapse="/")) %>% 
          arrange(pvalue, p.adjust)
        # Append description
        res.msigdf.em <- left_join(res.msigdf.em, m_t2d, by = c("ID" = "gs_name"))
        res.msigdf.em$Description <- res.msigdf.em$gs_description
        res.msigdf.em$gs_description <- NULL
        res.msigdf.em$geneID <- NULL
      } else {
        res.msigdf.em <- as.data.frame(matrix(data = "Nothing significant", nrow = 1,
                                              ncol = 10))
        colnames(res.msigdf.em) <- c("ID", "Description", "GeneRatio", "BgRatio",
                                     "pvalue", "p.adjust", "qvalue", "geneID", "Count", "Direction")
      }
    } else {
      # All genes
      em <- enricher(names(geneList_significant), TERM2GENE=m_t2g, pvalueCutoff = p_adj_cutoff)
      if (!is.null(em) | !any(is.na(em@result$qvalue))) {
        em@result <- em@result %>% dplyr::mutate(Direction = "ALL") # add new Direction column 
      }
      #  # Check if the results are non-empty
      if (!(is.null(em))) {
        res.msigdf.em <- rbind(em@result)
        res.msigdf.em <- res.msigdf.em[res.msigdf.em$p.adjust < p_adj_cutoff, , drop = FALSE]
        res.msigdf.em$core_enrichment <- entrez_to_symbols(res.msigdf.em$geneID, gene_annotations, ntop = ntop_symbols)
        # sort the genes alphabetically
        res.msigdf.em <- res.msigdf.em %>% 
          # separate the rows by splitting by the delimiter and expanding the rows 
          separate_rows(geneID, convert = TRUE, sep = "/") %>% 
          # group the genes by their other columns to keep them 
          group_by(ID, Description, GeneRatio, BgRatio, pvalue, p.adjust, qvalue, Count, Direction, core_enrichment) %>%
          # sort the genes for each term 
          arrange(geneID) %>% 
          summarise(geneID = paste(geneID, collapse="/")) %>% 
          arrange(pvalue, p.adjust)
        # Append description
        res.msigdf.em <- left_join(res.msigdf.em, m_t2d, by = c("ID" = "gs_name"))
        res.msigdf.em$Description <- res.msigdf.em$gs_description
        res.msigdf.em$gs_description <- NULL
      } else {
        res.msigdf.em <- as.data.frame(matrix(data = "Nothing significant", nrow = 1,
                                              ncol = 10))
        colnames(res.msigdf.em) <- c("ID", "Description", "GeneRatio", "BgRatio",
                                     "pvalue", "p.adjust", "qvalue", "geneID", "Count", "Direction")
      }
    }
    # Combine the results and add names
    res.msigdf.all <- c(res.msigdf.all, list(res.msigdf.em))
    names(res.msigdf.all)[length(res.msigdf.all)] <- paste0("Enrich.", gs_cat)
  }
  res.msigdf.all
}
# run unranked MSigDb analysis 
res.msigdb.enrich <- msigdb_enrich(dataset = res, p_adj_cutoff = p_adj_cutoff)
```

```{r gsea.kegg1, eval=FALSE}
# Function to perform GSEA analysis on KEGG
gsea_kegg_enrich <- function(dataset, p_adj_cutoff = p_adj_cutoff) {
  # All DEGs for GSEA
  # res.all <- dataset
  res.all <- dataset %>%
  group_by(symbol) %>%
  slice_max(order_by = abs(logFC), n = 1, with_ties = FALSE) %>%
  ungroup()
  # Convert symbols to entrezids
  eid <- bitr(unique(res.all$symbol), fromType="SYMBOL", toType="ENTREZID", OrgDb=OrgDb)
  # Attach converted entrezids
  res.all <- left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[ !is.na(res.all$ENTREZID), ]
  # List of t-statistics
  geneList <- res.all$logFC
  # Make it named
  names(geneList) <- res.all$ENTREZID
  # And decreasing sorted
  geneList <- sort(geneList, decreasing = TRUE)

  # Actual GSEA
  set.seed(1)
  ego3 <- gseKEGG(geneList     = geneList,
                  organism     = species,
                  # nPerm        = nperm,
                  minGSSize    = 10,
                  pvalueCutoff = 1,
                  verbose      = FALSE)
  # Get summary
  ego3 <- setReadable(ego3, OrgDb = OrgDb, keyType = "ENTREZID")
  res.kegg.gsea <- as.data.frame(ego3)
  # Process if non-empty
  if( nrow(res.kegg.gsea) > 0) {
    # Prepare for table output
  res.kegg.gsea <- res.kegg.gsea[, c("ID", "Description", "NES", "pvalue", "p.adjust", "core_enrichment")]
  # reorder the genes alphabetically 
    res.kegg.gsea <- res.kegg.gsea %>% 
      # separate the rows by splitting by the delimiter and expanding the rows 
      separate_rows(core_enrichment, convert = TRUE, sep = "/") %>% 
      # group the genes by their ID & other columns to keep them 
      group_by(ID, Description, NES, pvalue, p.adjust) %>% 
      # sort the genes for each term 
      arrange(core_enrichment) %>% 
      # now collapse them again so they will be sorted alphabetically 
      summarise(core_enrichment = paste(core_enrichment, collapse="/"))
    
    res.kegg.gsea <- res.kegg.gsea[order(abs(res.kegg.gsea$NES), decreasing = TRUE), ]
    res.kegg.gsea <- res.kegg.gsea[res.kegg.gsea$p.adjust < p_adj_cutoff, ]
    res.kegg.gsea$NES       <- round(res.kegg.gsea$NES, digits = 2)
    res.kegg.gsea$pvalue    <- formatC(res.kegg.gsea$pvalue, format = "e", digits = 2)
    res.kegg.gsea$p.adjust  <- formatC(res.kegg.gsea$p.adjust, format = "e", digits = 2)
    rownames(res.kegg.gsea) <- NULL
  } else {
    res.kegg.gsea <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 6))
    colnames(res.kegg.gsea) <- c("ID", "Description", "NES", "pvalue", "p.adjust", "core_enrichment")
  }
  return(res.kegg.gsea)
}

# run GSEA KEGG analysis 
res.kegg.gsea <- gsea_kegg_enrich(res, p_adj_cutoff = p_adj_cutoff)
```

```{r gsea.kegg21, eval=FALSE}
# Function to perform GSEA analysis on KEGG (returns ego3, the gseaResult object)
gsea_kegg_enrich <- function(dataset = res, p_adj_cutoff = 0.05) {
  res.all <- dataset %>%
    dplyr::group_by(symbol) %>%
    dplyr::slice_max(order_by = abs(logFC), n = 1, with_ties = FALSE) %>%
    dplyr::ungroup()
  eid <- bitr(unique(res.all$symbol), fromType = "SYMBOL", toType = "ENTREZID", OrgDb = OrgDb)
  res.all <- dplyr::left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[!is.na(res.all$ENTREZID), ]
  geneList <- res.all$logFC
  names(geneList) <- res.all$ENTREZID
  geneList <- sort(geneList, decreasing = TRUE)
  set.seed(1)
  ego3 <- gseKEGG(
    geneList     = geneList,
    organism     = species,
    minGSSize    = 10,
    pvalueCutoff = 1,
    verbose      = FALSE
  )
  ego3 <- setReadable(ego3, OrgDb = OrgDb, keyType = "ENTREZID")
  return(ego3)
}

res.kegg.ego3 <- gsea_kegg_enrich(res, p_adj_cutoff = p_adj_cutoff)

# Function to reformat gseaResult object into processed data frame
gsea_kegg_results_to_df <- function(ego3, p_adj_cutoff = 0.05) {
  res.kegg.gsea <- as.data.frame(ego3)
  if (nrow(res.kegg.gsea) > 0) {
    res.kegg.gsea <- res.kegg.gsea[, c("ID", "Description", "NES", "pvalue", "p.adjust", "core_enrichment")]
    res.kegg.gsea <- res.kegg.gsea %>%
      tidyr::separate_rows(core_enrichment, convert = TRUE, sep = "/") %>%
      dplyr::group_by(ID, Description, NES, pvalue, p.adjust) %>%
      dplyr::arrange(core_enrichment) %>%
      dplyr::summarise(core_enrichment = paste(core_enrichment, collapse = "/"), .groups = "drop")
    res.kegg.gsea <- res.kegg.gsea[order(abs(res.kegg.gsea$NES), decreasing = TRUE), ]
    res.kegg.gsea <- res.kegg.gsea[res.kegg.gsea$p.adjust < p_adj_cutoff, ]
    res.kegg.gsea$NES       <- round(res.kegg.gsea$NES, digits = 2)
    res.kegg.gsea$pvalue    <- formatC(res.kegg.gsea$pvalue, format = "e", digits = 2)
    res.kegg.gsea$p.adjust  <- formatC(res.kegg.gsea$p.adjust, format = "e", digits = 2)
    rownames(res.kegg.gsea) <- NULL
  } else {
    res.kegg.gsea <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 6))
    colnames(res.kegg.gsea) <- c("ID", "Description", "NES", "pvalue", "p.adjust", "core_enrichment")
  }
  return(res.kegg.gsea)
}

res.kegg.gsea <- gsea_kegg_results_to_df(res.kegg.ego3, p_adj_cutoff = p_adj_cutoff)

plot_disc <- c("Expression enrichment to reponses to staphylococcus aureus infection as illustrated by the GSEA plot.",
               "Expression enrichment characterized in complement and coagulation cascades illustrated by the GSEA plot.",
               "Expression enrichment to reponses to leishmaniasis infection as illustrated by the GSEA plot.")

# Plot the top enriched pathways
for (i in 1:num_gseaplots) {
  pathway_id <- res.kegg.gsea$ID[i]
  pathway_desc <- res.kegg.gsea$Description[i]
  print(gseaplot2(res.kegg.ego3, geneSetID = pathway_id, title = paste0("Figure ", as.character(i+15), ": ", pathway_desc)))
  cat(plot_disc[i])
}
```

```{r gsea.msig1, eval=FALSE}
# Function to perform GSEA analysis using MSigDb signatures
gsea_msigdb_enrich <- function(dataset, p_adj_cutoff = p_adj_cutoff) {
  res.all <- dataset %>%
  group_by(symbol) %>%
  slice_max(order_by = abs(logFC), n = 1, with_ties = FALSE) %>%
  ungroup()
  # Convert symbols to entrezids
  eid <- bitr(res.all$symbol, fromType="SYMBOL", toType="ENTREZID", OrgDb=OrgDb)
  # Attach converted entrezids
  res.all <- left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[ !is.na(res.all$ENTREZID), ]
  # List of t-statistics
  geneList <- res.all$logFC
  # Make it named
  names(geneList) <- res.all$ENTREZID
  # And decreasing sorted
  geneList <- sort(geneList, decreasing = TRUE)
  # Actual MSIGDB
  res.msigdf.all <- list()
  # gs_cat="H" # For testing
  for (gs_cat in m_df_gs_cat) {
    # Term to gene
     m_t2g <- msigdbr(species = msigdbr_org, collection = gs_cat) %>% 
       dplyr::distinct(gs_name, ncbi_gene)
    # Term to description 
    m_t2d <- msigdbr(species = msigdbr_org, collection = gs_cat) %>% 
       dplyr::distinct(gs_name, gs_description)
    # Enrichment analysis
    em2 <- GSEA(geneList, TERM2GENE = m_t2g, pvalueCutoff = p_adj_cutoff)
    # Check if the results are non-empty
    if (nrow(em2@result) > 0) {
      res.msigdf.em2 <- em2@result
      res.msigdf.em2$core_enrichment <- entrez_to_symbols(res.msigdf.em2$core_enrichment, gene_annotations, ntop = ntop_symbols)
      # sort the genes alphabetically
      res.msigdf.em2 <- res.msigdf.em2 %>% 
      # separate the rows by splitting by the delimiter and expanding the rows 
      separate_rows(core_enrichment, convert = TRUE, sep = "/") %>% 
      # group the genes by their other columns to keep them 
      group_by(ID, Description, setSize, enrichmentScore, NES, pvalue, p.adjust, qvalue,
               rank, leading_edge) %>%
      # sort the genes for each term 
      arrange(core_enrichment) %>% 
      summarise(core_enrichment = paste(core_enrichment, collapse="/")) %>% 
      arrange(pvalue, p.adjust) 
      # Append description
      res.msigdf.em2 <- left_join(res.msigdf.em2, m_t2d, by = c("ID" = "gs_name"))
      res.msigdf.em2$Description <- res.msigdf.em2$gs_description
      res.msigdf.em2$gs_description <- NULL
    } else {
      res.msigdf.em2 <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 11))
      colnames(res.msigdf.em2) <- c("ID", "Description", "setSize", "enrichmentScore", "NES", "pvalue", "p.adjust", "qvalues", "rank", "leading_edge", "core_enrichment")
      # res.msigdf.em2 <- res.msigdf.em2 %>% # drop unneeded columns
      # dplyr::filter(-c(setSize, enrichmentScore, qvalues, rank, leading_edge))
    }
    
    res.msigdf.all <- c(res.msigdf.all, list(res.msigdf.em2))
    names(res.msigdf.all)[length(res.msigdf.all) - 0] <- paste0("GSEA.", gs_cat)
  }
  return(res.msigdf.all)
}

# call GSEA MSigDb
res.msigdb <- c(res.msigdb, gsea_msigdb_enrich(res, p_adj_cutoff = p_adj_cutoff))
```

```{r gsea.msig21, eval=FALSE}
# Function to perform GSEA analysis using MSigDb signatures
gsea_msigdb_enrich <- function(dataset, p_adj_cutoff = 0.05) {
  # Preprocess dataset: get the most significant gene per symbol
  res.all <- dataset %>%
    dplyr::group_by(symbol) %>%
    dplyr::slice_max(order_by = abs(logFC), n = 1, with_ties = FALSE) %>%
    dplyr::ungroup()
  # Convert gene symbols to entrez IDs
  eid <- bitr(res.all$symbol, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = OrgDb)
  res.all <- dplyr::left_join(res.all, eid, by = c("symbol" = "SYMBOL"))
  res.all <- res.all[!is.na(res.all$ENTREZID), ]
  # Named gene list
  geneList <- res.all$logFC
  names(geneList) <- res.all$ENTREZID
  geneList <- sort(geneList, decreasing = TRUE)
  # GSEA for each MSigDB category
  res.msigdb.all <- list()
  for (gs_cat in m_df_gs_cat) {
    m_t2g <- msigdbr(species = msigdbr_org, collection = gs_cat) %>%
      dplyr::distinct(gs_name, ncbi_gene)
    em2 <- GSEA(geneList, TERM2GENE = m_t2g, pvalueCutoff = p_adj_cutoff)
    res.msigdb.all[[paste0("GSEA.", gs_cat)]] <- em2
  }
  return(res.msigdb.all)
}

res.msigdb.em2 <- gsea_msigdb_enrich(res, p_adj_cutoff = p_adj_cutoff)
  
  
# Function to reformat a list of GSEA results into a list of data frames
gsea_msigdb_results_to_df <- function(res.msigdb.all, gene_annotations, msigdbr_org) {
  res.msigdf.all <- list()
  for (nm in names(res.msigdb.all)) {
    em2 <- res.msigdb.all[[nm]]
    # Term to description 
    res.msigdf.em2 <- NULL
    if (nrow(em2@result) > 0) {
      gs_cat <- sub("GSEA.", "", nm)
      m_t2d <- msigdbr(species = msigdbr_org, collection = gs_cat) %>%
        dplyr::distinct(gs_name, gs_description)
      res.msigdf.em2 <- em2@result
      res.msigdf.em2$core_enrichment <- entrez_to_symbols(res.msigdf.em2$core_enrichment, gene_annotations, ntop = ntop_symbols)
      res.msigdf.em2 <- res.msigdf.em2 %>%
        tidyr::separate_rows(core_enrichment, convert = TRUE, sep = "/") %>%
        dplyr::group_by(ID, Description, setSize, enrichmentScore, NES, pvalue, p.adjust, qvalue,
                        rank, leading_edge) %>%
        dplyr::arrange(core_enrichment) %>%
        dplyr::summarise(core_enrichment = paste(core_enrichment, collapse = "/"), .groups = "drop") %>%
        dplyr::arrange(pvalue, p.adjust)
      # Append description
      res.msigdf.em2 <- dplyr::left_join(res.msigdf.em2, m_t2d, by = c("ID" = "gs_name"))
      res.msigdf.em2$Description <- res.msigdf.em2$gs_description
      res.msigdf.em2$gs_description <- NULL
    } else {
      res.msigdf.em2 <- as.data.frame(matrix(data = "Nothing significant", nrow = 1, ncol = 11))
      colnames(res.msigdf.em2) <- c("ID", "Description", "setSize", "enrichmentScore", "NES", "pvalue", "p.adjust", "qvalues", "rank", "leading_edge", "core_enrichment")
    }
    res.msigdf.all[[nm]] <- res.msigdf.em2
  }
  return(res.msigdf.all)
}

res.msigdb <- gsea_msigdb_results_to_df(res.msigdb.all = res.msigdb.em2, gene_annotations = gene_annotations, msigdbr_org = msigdbr_org)

# Plot the top enriched pathways
plot_disc <- c("Genes up-regulated in pulpal tissue extracted from carious teeth (GSEA (2025)).",
          "Age up-regulated genes in the human frontal cortex (GSEA (2025)).",
          "Inflammatory cytokines, chemokines and their cognate receptors up-regulated in THP-1 cells (monocyte) after treatment with PSMD4 (GSEA (2025))."
          )
  
  
for (catname in names(res.msigdb.em2)[1]) {
  gsea_res <- res.msigdb.em2[[catname]]
  gsea_df <- as.data.frame(gsea_res)
  for (i in seq_len(min(num_gseaplots, nrow(gsea_df)))) {
    pathway_id <- gsea_df$ID[i]
    pathway_desc <- gsea_df$Description[i]
    print(
      gseaplot2(
        gsea_res,
        geneSetID = pathway_id,
        title = paste0("Figure", as.character(i+18), ": ", catname, ": ", pathway_desc)
      )
    )
    cat(plot_disc[i])
  }
}

plot_disc <- c("An immune response mediated through a body fluid (GSEA (2025)).",
          "Any process that stops, prevents, or reduces the frequency, rate, or extent of an immune effector process (GSEA (2025)).",
          "Any process that activates or increases the frequency, rate or extent of the inflammatory response (GSEA (2025))."
          )

for (catname in names(res.msigdb.em2)[2]) {
  gsea_res <- res.msigdb.em2[[catname]]
  gsea_df <- as.data.frame(gsea_res)
  for (i in seq_len(min(num_gseaplots, nrow(gsea_df)))) {
    pathway_id <- gsea_df$ID[i]
    pathway_desc <- gsea_df$Description[i]
    print(
      gseaplot2(
        gsea_res,
        geneSetID = pathway_id,
        title = paste0("Figure ", as.character(i+21), ": ", catname, ": ", pathway_desc)
      )
    )
    cat(plot_disc[i])
  }
}

plot_disc <- c("Genes up-regulated by IL6 [GeneID=3569] via STAT3 [GeneID=6774], e.g., during acute phase response (GSEA (2025)).",
          "Genes up-regulated in response to IFNG [GeneID=3458] (GSEA (2025)).",
          "Genes up-regulated in response to alpha interferon proteins (GSEA (2025)).")

for (catname in names(res.msigdb.em2)[3]) {
  gsea_res <- res.msigdb.em2[[catname]]
  gsea_df <- as.data.frame(gsea_res)
  for (i in seq_len(min(num_gseaplots, nrow(gsea_df)))) {
    pathway_id <- gsea_df$ID[i]
    pathway_desc <- gsea_df$Description[i]
    print(
      gseaplot2(
        gsea_res,
        geneSetID = pathway_id,
        title = paste0("Figure", " ", as.character(i+24), ": ", catname, ": ", pathway_desc)
      )
    )
    cat(plot_disc[i])
  }
}
```

```{r msig_combine1, eval=FALSE}
# empty list to hold results from unranked MSigDb and GSEA MSigDb in order grouped by enrichment category 
res.msigdf.all <- list()

# iterate through length of each list of dataframes, doesn't matter which 
for (i in 1:length(names(res.msigdb))) {
  # add unranked MsigDB results first 
  res.msigdf.all[[length(res.msigdf.all) + 1]] = res.msigdb[[i]]
  names(res.msigdf.all)[[length(res.msigdf.all)]] = names(res.msigdb[i])
  # # add GSEA MsigDB next 
  # res.msigdf.all[[length(res.msigdf.all)+1]] = res.msigdb.gsea[[i]]
  # names(res.msigdf.all)[[length(res.msigdf.all)]] = names(res.msigdb.gsea[i])
}
```

```{r msig_combine21, eval=FALSE}
# Interleave two named lists of the same length
interleave_lists <- function(list1, list2) {
  n <- length(list1)
  if (length(list2) != n) stop("Lists must have the same length")
  names1 <- names(list1)
  names2 <- names(list2)
  out <- vector("list", 2 * n)
  out_names <- character(2 * n)
  out[seq(1, 2*n, by=2)] <- list1
  out[seq(2, 2*n, by=2)] <- list2
  out_names[seq(1, 2*n, by=2)] <- names1
  out_names[seq(2, 2*n, by=2)] <- names2
  names(out) <- out_names
  out
}

# Example usage:
res.msigdf.all <- interleave_lists(res.msigdb.enrich, res.msigdb)
```

```{r eval=FALSE}
x <- c(list(Enrich.KEGG = res.kegg), list(GSEA.KEGG = res.kegg.gsea), res.msigdf.all) # 
# names(x)[1:2] <- c("Enrich.KEGG", "GSEA.KEGG")
write_xlsx(x, path = fileNameOut1)
```

```{r , eval=FALSE}
# Create custom signatures for KEGG pathways
library(KEGGREST)
gs_cat <- "KEGG"
gs_selected <- "KEGG_Breast_cancer"
# Get numerical EntrezIDs
query <- keggGet("hsa05224")
query_gene <- query[[1]]$GENE[grepl("^[0-9]", query[[1]]$GENE, perl = TRUE)]
# The actual custom signature
m_t2g <- data.frame(gs_name = gs_selected, entrez_gene = query_gene)

# Use standard MSigDb sitnatures
gs_cat <- "C5"
gs_selected_all <- c("GOCC_CYTOSOLIC_RIBOSOME", "GOBP_DEFENSE_RESPONSE")

# For each signature
for (gs_selected in gs_selected_all) {
  print(gs_selected)
  # gs_selected <- "HALLMARK_DNA_REPAIR"
  # Do the enrichment analysis
  m_t2g <- msigdbr(species = "Homo sapiens", collection = gs_cat) %>% dplyr::distinct(gs_name, entrez_gene) %>% dplyr::filter(gs_name == !!gs_selected)
  em2 <- GSEA(geneList, TERM2GENE = m_t2g, pvalueCutoff = p_adj_cutoff)
  # Save the picture
  gseaplot(em2, geneSetID = 1, by = "runningScore")
  ggsave(filename = file.path(data_dir, paste0("results/Figure_GSEA_", gs_cat, "_", gs_selected, ".svg")), width = 4, height = 2.6, units = "in")
}
```

```{r eval=FALSE}
# Load library
library(dplyr)
# Create bar graph.
y <- # Assign to new variable
x[[1]] %>% # Get data. 
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 4]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = Term, x = neglog10.Adjusted.P.value, fill = Term)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + 
  ggtitle("Figure 28: Enrich.KEGG") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = str_wrap("The top 10 most significantly  enrich KEGG pathways without considering DEG order. The adjusted p-value has been scaled with -log10."))

```

```{r eval=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[2]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 7]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 29: GSEA.KEGG") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label 
  labs(caption = str_wrap("The top 10 most significantly  enrich GSEA KEGG pathways considering largest to smallest order of DEGs. The adjusted p-value has been scaled with -log10."))

```

```{r, eval=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[3]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 30: Enrich.C2") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = str_wrap("The top 11 most significantly  enrich pathways  without considering DEG order. Curated gene sets from online pathway databases, publications in PubMed, and knowledge of domain experts (Dozmorov (2025)). The adjusted p-value has been scaled with -log10."))

```

```{r eval=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[4]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        axis.text.x = element_text(size = 8),
        plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0 ),
        axis.text.y = element_text(size = 5)) + # remove legend
  ggtitle("Figure 31: GSEA.C2") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = str_wrap("The top most significantly  enrich GSEA pathways considering largest to smallest order of DEGs. Curated gene sets from online pathway databases, publications in PubMed, and knowledge of domain experts (Dozmorov (2025)). The adjusted p-value has been scaled with -log10."))
```

```{r eval=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[5]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 32: Enrich.C5") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = str_wrap("The top most significantly  enrich pathways without considering DEG order. GO gene sets  consist of genes annotated by the same GO terms. (Dozmorov (2025)). The adjusted p-value has been scaled with -log10."))
```

```{r eval=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[6]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[11, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.

  scale_y_discrete(labels = function(x) {
    # Define the maximum number of characters
    max_chars <- 20
    
    # Truncate labels longer than max_chars and add "..."
    ifelse(nchar(x) > max_chars, paste0(substr(x, 1, max_chars), "..."), x)
  }) +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 8),
        plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0 ),
        axis.text.y = element_text(size = 5)) + # remove legend
  ggtitle("Figure 33: GSEA.C5") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  coord_cartesian(xlim = c(3, 7)) +
  labs(caption = str_wrap("The top most significantly  enrich GSEA pathways considering largest to smallest order of DEGs. GO gene sets  consist of genes annotated by the same GO terms. (Dozmorov (2025)). The adjusted p-value has been scaled with -log10."))

# google("r ggplot2 limit number of characters in y axis")
```

```{r eval=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[7]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 34: Enrich.H") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
   labs(caption = str_wrap("The top most significantly  enrich hallmark gene sets pathways  without considering DEG order. The adjusted p-value has been scaled with -log10."))
```

```{r eval=FALSE}
# Create bar graph.
y <- # Assign to new variable
x[[8]] %>% # Get data. 
  dplyr::mutate(., Adjusted.P.value = as.numeric(p.adjust)) %>%
  dplyr::arrange(., Adjusted.P.value) %>% # Arrange by adjusted p-value
  dplyr::mutate(., neglog10.Adjusted.P.value = -log10(Adjusted.P.value)) # -1og10 the adjusted p-value

y <- # Assign to self
  y %>% # Call data.
  dplyr::filter(., Adjusted.P.value <= y[10, 12]$Adjusted.P.value) # Get top terms based on p-value

ggplot(y, aes(y = ID, x = neglog10.Adjusted.P.value, fill = ID)) + # Start ggplot
  geom_col() + # Create col plot.
  theme(legend.position = "none",
        plot.caption = element_text(
          size = 10,      
          color = "black", 
          face = "italic",    
          hjust = 0 )) + # remove legend
  ggtitle("Figure 35: GSEA.H") + # Add title.
  xlab("-log10(Adjusted p-Value)") + # Add x label
  labs(caption = str_wrap("The top most significantly  enrich GSEA hallmark gene sets pathways considering largest to smallest order of DEGs. The adjusted p-value has been scaled with -log10."))
```

```{r Terms of interest1, eval=FALSE}
# Terms of interest
key_terms <- c("synaptic", "cognition", "memory", "DNA damage", "mitochendrial", "mitochendria", "regulatory stress", "oxidative stress",
               "vesicular", "calcium homeostasis", "insulin", "aging", "age", "brain", "Synaptic", "Cognition", "Memory", "DNA damage",
               "Mitochendrial", "Mitochendria", "Regulatory stress", "Oxidative stress", "Vesicular", "Calcium homeostasis", "Insulin", 
               "Aging", "Age", "Brain")
# First data.frame
KEY_TERM_DF1 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF1 <- rbind(KEY_TERM_DF1, x[1]$Enrich.KEGG[grepl(term, x[1]$Enrich.KEGG$Term), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF1 <- KEY_TERM_DF1[as.numeric(KEY_TERM_DF1$Adjusted.P.value) < 0.05,]

# Look for key terms
# Second data.frame
KEY_TERM_DF2 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF2 <- rbind(KEY_TERM_DF2, x[[2]][grepl(term, x[[2]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF2 <- KEY_TERM_DF2[as.numeric(KEY_TERM_DF2$p.adjust) < 0.05,]

# Third data.frame
KEY_TERM_DF3 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF3 <- rbind(KEY_TERM_DF3, x[[3]][grepl(term, x[[3]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF3 <- KEY_TERM_DF3[as.numeric(KEY_TERM_DF3$p.adjust) < 0.05,]

# Forth data.frame
KEY_TERM_DF4 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF4 <- rbind(KEY_TERM_DF4, x[[4]][grepl(term, x[[4]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF4 <- KEY_TERM_DF4[as.numeric(KEY_TERM_DF4$p.adjust) < 0.05,]

# Fifth data.frame
KEY_TERM_DF5 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF5 <- rbind(KEY_TERM_DF5, x[[5]][grepl(term, x[[5]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF5 <- KEY_TERM_DF5[as.numeric(KEY_TERM_DF5$p.adjust) < 0.05,]

# Sixth data.frame  
KEY_TERM_DF6 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF6 <- rbind(KEY_TERM_DF6, x[[6]][grepl(term, x[[6]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF6 <- KEY_TERM_DF6[as.numeric(KEY_TERM_DF6$p.adjust) < 0.05,]

# Seventh data.frame
KEY_TERM_DF7 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF7 <- rbind(KEY_TERM_DF7, x[[7]][grepl(term, x[[7]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF7 <- KEY_TERM_DF7[as.numeric(KEY_TERM_DF7$p.adjust) < 0.05,]

# Eighth data.frame
KEY_TERM_DF8 <- data.frame()
# Look for key terms
for (term in key_terms) {
  KEY_TERM_DF8 <- rbind(KEY_TERM_DF8, x[[8]][grepl(term, x[[8]]$Description), ])
}
# Filter out p-values above 0.05
KEY_TERM_DF8 <- KEY_TERM_DF8[as.numeric(KEY_TERM_DF8$p.adjust) < 0.05,]
# List of descriptions
Term_check_list <- c(KEY_TERM_DF1$Term, KEY_TERM_DF2$Description, KEY_TERM_DF3$Description, KEY_TERM_DF4$Description,
                      KEY_TERM_DF5$Description, KEY_TERM_DF6$Description, KEY_TERM_DF7$Description, 
                     KEY_TERM_DF8$Description)
# Check if all terms met.
Count_of_term <- c()
for (term in key_terms) {
  sum_count <- (sum(grepl(term, Term_check_list)))
  Count_of_term <- c(Count_of_term, sum_count)
}
# Create key terms that are present
key_term_df <- data.frame(Terms = key_terms,
                          Counts = Count_of_term)
knitr::kable(key_term_df, caption = "Table 7: Count of Key Terms Functional Enrichment Analysis.") %>% kable_styling(full_width = FALSE) %>% add_footnote( label = "*Key terms were taken from the source study (Mavrikaki (2022)). These terms were searched for in the function enrichment analysis and counted.*")
```

# REFERENCE